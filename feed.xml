<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/">
    <title>Huy Phuong&#x27;s Blog</title>
    <link href="https://github.com/HuyPhuongVN/PhuongBlog.git/feed.xml" rel="self" />
    <link href="https://github.com/HuyPhuongVN/PhuongBlog.git" />
    <updated>2024-12-29T17:24:58+07:00</updated>
    <author>
        <name>Trần Huy Phương</name>
    </author>
    <id>https://github.com/HuyPhuongVN/PhuongBlog.git</id>

    <entry>
        <title>Mục lục</title>
        <author>
            <name>Trần Huy Phương</name>
        </author>
        <link href="https://github.com/HuyPhuongVN/PhuongBlog.git/posts/muc-luc/"/>
        <id>https://github.com/HuyPhuongVN/PhuongBlog.git/posts/muc-luc/</id>

        <updated>2024-12-29T13:16:47+07:00</updated>
            <summary>
                <![CDATA[
                    Mục lục về các bài học: Bài 1: CÁC KHÁI NIỆM CƠ BẢN VỀ MẠNG MÁY TÍNH Bài 2: CÁC DÒNG VÀO-RA (STREAM) Bài 3: LẬP TRÌNH ĐA LUỒNG TRONG JAVA Bài 4: LỚP INETADDRESS Bài 5: LẬP TRÌNH VỚI GIAO THỨC TCP Bài 6:&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <h1>Mục lục về các bài học:</h1>
<h2><a href="https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-1-tong-quan-ve-lap-trinh-mang/">Bài 1: CÁC KHÁI NIỆM CƠ BẢN VỀ MẠNG MÁY TÍNH</a></h2>
<h2><a href="https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-2-quan-ly-cac-luong-io/">Bài 2: CÁC DÒNG VÀO-RA (STREAM)</a></h2>
<h2><a href="https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-3-lap-trinh-da-tuyen/">Bài 3: LẬP TRÌNH ĐA LUỒNG TRONG JAVA</a></h2>
<h2><a href="https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-4-quan-ly-dia-chi-ket-noi-mang/">Bài 4: LỚP INETADDRESS</a></h2>
<h2><a href="https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-5-lap-trinh-socket-cho-giao-thuc-tcp/">Bài 5: LẬP TRÌNH VỚI GIAO THỨC TCP</a></h2>
<h2><a href="https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-6-ky-thuat-da-tien-trinh-va-tuan-tu-hoa-ung-dung-mang/">Bài 6: Lập trình giao thức UDP</a></h2>
<h2><a href="https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-7-lap-trinh-socket-cho-giao-thuc-udp/">Bài 7: Kỹ thuật lập trình phân tán RMI</a></h2>
<h2><a href="https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-8-lap-trinh-multicast/">Bài 8: Lập trình mạng an toàn bảo mật với SSL</a></h2>
<h2><a href="https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-9-phan-tan-doi-tuong-trong-java-bang-rmi/">Bài 9: Lập trình ứng dụng truyền thông qua mạng điện thoại công cộng (PTSN)</a></h2>
            ]]>
        </content>
    </entry>
    <entry>
        <title>About me</title>
        <author>
            <name>Trần Huy Phương</name>
        </author>
        <link href="https://github.com/HuyPhuongVN/PhuongBlog.git/posts/about-me-2/"/>
        <id>https://github.com/HuyPhuongVN/PhuongBlog.git/posts/about-me-2/</id>

        <updated>2024-12-29T12:10:50+07:00</updated>
            <summary>
                <![CDATA[
                    Tôi là Trần Huy Phương, sinh viên năm 4 tại Đại học HUTECH, đam mê lập trình game và luôn mong muốn nâng cao kỹ năng trong lĩnh vực này. Tôi tạo blog này để chia sẻ kiến thức, dự án và hành trình phát&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Tôi là Trần Huy Phương, sinh viên năm 4 tại Đại học HUTECH, đam mê lập trình game và luôn mong muốn nâng cao kỹ năng trong lĩnh vực này. Tôi tạo blog này để chia sẻ kiến thức, dự án và hành trình phát triển nghề nghiệp trong lập trình game, đồng thời kết nối với cộng đồng và tìm kiếm cơ hội nghề nghiệp.</p>
<p> </p>
<p>Những thành tựu mình đạt được trong 4 năm đại học:</p>
<div class="gallery-wrapper"><div class="gallery"  data-is-empty="false" data-translation="Add images" data-columns="3">
<figure class="gallery__item"><a href="https://github.com/HuyPhuongVN/PhuongBlog.git/media/posts/11/gallery/Screenshot-2024-12-29-123915.png" data-size="1054x816"><img loading="lazy" src="https://github.com/HuyPhuongVN/PhuongBlog.git/media/posts/11/gallery/Screenshot-2024-12-29-123915-thumbnail.png" alt="" width="720" height="557"></a></figure>
<figure class="gallery__item"><a href="https://github.com/HuyPhuongVN/PhuongBlog.git/media/posts/11/gallery/chungnhan_47012.png" data-size="3371x2420"><img loading="lazy" src="https://github.com/HuyPhuongVN/PhuongBlog.git/media/posts/11/gallery/chungnhan_47012-thumbnail.png" alt="" width="720" height="517"></a></figure>
<figure class="gallery__item"><a href="https://github.com/HuyPhuongVN/PhuongBlog.git/media/posts/11/gallery/chungnhan_49063.png" data-size="3371x2420"><img loading="lazy" src="https://github.com/HuyPhuongVN/PhuongBlog.git/media/posts/11/gallery/chungnhan_49063-thumbnail.png" alt="" width="720" height="517"></a></figure>
<figure class="gallery__item"><a href="https://github.com/HuyPhuongVN/PhuongBlog.git/media/posts/11/gallery/chungnhan_75110.png" data-size="3371x2420"><img loading="lazy" src="https://github.com/HuyPhuongVN/PhuongBlog.git/media/posts/11/gallery/chungnhan_75110-thumbnail.png" alt="" width="720" height="517"></a></figure>
<figure class="gallery__item"><a href="https://github.com/HuyPhuongVN/PhuongBlog.git/media/posts/11/gallery/Tran-Huy-Phuong.jpg" data-size="3503x2479"><img loading="lazy" src="https://github.com/HuyPhuongVN/PhuongBlog.git/media/posts/11/gallery/Tran-Huy-Phuong-thumbnail.jpg" alt="" width="720" height="509"></a></figure>
<figure class="gallery__item"><a href="https://github.com/HuyPhuongVN/PhuongBlog.git/media/posts/11/gallery/chungnhan_91130.png" data-size="3371x2420"><img loading="lazy" src="https://github.com/HuyPhuongVN/PhuongBlog.git/media/posts/11/gallery/chungnhan_91130-thumbnail.png" alt="" width="720" height="517"></a></figure>
</div></div>
<p> </p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Chương 9: Phân tán đói tượng trong Java bằng RMI</title>
        <author>
            <name>Trần Huy Phương</name>
        </author>
        <link href="https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-9-phan-tan-doi-tuong-trong-java-bang-rmi/"/>
        <id>https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-9-phan-tan-doi-tuong-trong-java-bang-rmi/</id>

        <updated>2024-12-27T19:37:30+07:00</updated>
            <summary>
                <![CDATA[
                    Khái niệm RMI RMI - Remote Method Invocation là một kĩ thuật cài đặt các đối tượng phân tán trong Java. RMI là một phần của bộ J2SDK và là hàm thư viện hỗ trợ các lời gọi phương thức từ xa và trả về&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <h3 id="_khai-niem-rmi-0">Khái niệm RMI</h3>
<p><strong>RMI - Remote Method Invocation là một kĩ thuật cài đặt các đối tượng phân tán trong Java. RMI là một phần của bộ J2SDK và là hàm thư viện hỗ trợ các lời gọi phương thức từ xa và trả về giá trị cho các ứng dụng tính toán phân tán. Chúng ta giả sử rằng ngôn ngữ Java được sử dụng ở cả hai phía gọi và phía bên phương thức được gọi.</strong></p>
<p><em>Để giải quyết một số vấn đề trong việc truyền thông giữa Client/Server. RMI không gọi trực tiếp mà thông qua lớp trung gian. Lớp này tồn tại ở cả hai phía Client và Server. Lớp ở máy Client gọi là Stub, lớp ở máy Server gọi là Skel (Skeletion).</em></p>
<h3 id="_dac-tinh-cua-rmi-1">Đặc tính của RMI</h3>
<ul>
<li>RMI là mô hình đối tượng phân tán của Java, RMI giup cho việc giao tiếp giuẵ các đối tượng phân tán trong môi trường internet trể nên dễ dàng hơn.</li>
<li>RMI là API bậc cao được xây dựng dựa trên lập trình Socket.</li>
<li>RMI không những cho phép chúng ta truyền dữ liệu giữa các đối tượng trên các hệ thống máy tính khác nhau, mà còn triệu gọi các phương thức trong các đối tượng ở xa (Remote Object).</li>
<li>Việc truyền dữ liệu giữa các máy khác nhau được xử lý một cách trong suốt bởi máy ảo Java (Java virtual machine).</li>
<li>Tương tự như mô hình Client/Server, RMI vẫn lấy/duy trì khái niệm của Client và Server, tuy nhiên cách tiếp cận (approach) của RMI linh hoạt hơn, mềm dẻo hơn so với môt hình Client/Server.</li>
<li>Một điều thuận lợi quan trong nhất của RMI là nó cung cấp cớ chế callbacks, nó cho phép Server triệu gọi các phương thức ở Client.</li>
</ul>
<h3 id="_rmi-architecture-2">RMI Architecture</h3>
<ul>
<li>Remote interface: Nên extend từ java.rmi.remote. Nó khai báo tất cả các phương thức mà Client có thể triệu gọi. Tất cả các method trong interface này nên throw RemoteException</li>
<li>Remote implementation: Được thực thi từ Remote interface và mở rộng từ UnicastRemoteObject. Triển khai các method được khai báo trong Interface tại đây. Nó là một Remote Object thực sự. Phát sinh hai lớp trung gian Stub và Skel.</li>
<li>Server class bao gồm:</li>
</ul>
<ul>
<li>RMI registry: Bộ đăng kí này sẽ đăng kí một Remote object với Naming Registry. Giúp các Remote object được chấp nhận khi gọi các method từ xa.</li>
<li>Các class thực thi trên server.</li>
</ul>
<ul>
<li>Client class: Truy vấn trên tên Remote object trên RMI registry, thông qua stub để gọi các phương thức trên server.</li>
</ul>
<figure class="article-img"><img loading="lazy"  src="https://docs.oracle.com/javase/tutorial/figures/rmi/rmi-2.gif" alt="alt" data-is-external-image="true"></figure>
<p>RMI Architecture (Ảnh: <a href="http://docs.oracle.com/" target="_blank" rel="noopener">docs.oracle.com</a>)</p>
<h3 id="_tao-mot-chuong-trinh-don-gian-su-dung-rmi-3">Tạo một chương trình đơn gỉan sử dụng RMI</h3>
<p><em>Ở đâu tôi sẽ tạo một project đơn giản để các bạn hiểu thêm về cách thức khai báo cũng như remote của RMI.</em></p>
<ul>
<li>OS: Linux Ubuntu 15.04</li>
<li>Java: version 1.7</li>
<li>IDE: IntelliJ IDEA 15.0.3 (hoặc bất kỳ IDE nào các bạn cảm thấy tiện cho mình)</li>
</ul>
<h4>Tạo mới một server để có thể remote từ xa</h4>
<p>Đầu tiên chúng ta sẽ tạo một Interface để khai báo những method chúng ta sẽ sử dụng khi remote. Interface là <code>RMICalcul</code> và nó extends <code>Remote</code></p>
<figure class="article-img"><img loading="lazy"  src="https://images.viblo.asia/9361ec5e-e3ad-40ce-ac37-0d8a1ff01727.png" alt="Selection_041.png" data-is-external-image="true"></figure>
<div style="box-sizing: border-box; color: #1b1b1b; font-family: 'Open Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol'; font-size: 18px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: #ffffff; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; position: relative;">
<pre class="language-java" data-filename=""><code>/**
 * Created by tranducliem on 3/26/16.
 */

import java.rmi.*;

public interface RMICalcul extends Remote {
    public int add (int a, int b) throws RemoteException;
    public int sub (int a, int b) throws RemoteException;
    public double convert (int f) throws RemoteException;
}
</code></pre>
<button class="v-markdown-it-code-copy" title="Sao chép" data-clipboard-text="/**
 * Created by tranducliem on 3/26/16.
 */

import java.rmi.*;

public interface RMICalcul extends Remote {
    public int add (int a, int b) throws RemoteException;
    public int sub (int a, int b) throws RemoteException;
    public double convert (int f) throws RemoteException;
}
"></button></div>
<p>Sau đó chúng ta tạo một class <code>RMICalculimpl</code> và implements 2 interface là <code>RMICalcul</code> và <code>Serializable</code></p>
<blockquote>
<p>Lưu ý: RMICalcul là interface do chúng ta tạo ra còn Serializable là interface có sẵn trong java, bất cứ object nào muốn send qua môi trường mạng (internet) đều phải implements Serializable. Hiểu đơn giản thì interface Serializable sẽ có nhiệm vụ đóng băng trạng thái của object trước khi được gửi qua môi trường mạng.</p>
</blockquote>
<div class="v-markdown-content-box" style="box-sizing: border-box; max-height: 300px; padding-bottom: 1rem; cursor: pointer; mask-image: linear-gradient(#000000 60%, transparent); color: #1b1b1b; font-family: 'Open Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol'; font-size: 18px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: #ffffff; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; position: relative;">
<pre class="language-java" data-filename=""><code>import java.io.Serializable;
import java.rmi.RemoteException;

/**
 * Created by tranducliem on 3/26/16.
 */
public class RMICalculimpl implements RMICalcul, Serializable {
    @Override
    public int add(int a, int b) throws RemoteException {
        return a + b;
    }

    @Override
    public int sub(int a, int b) throws RemoteException {
        return a - b;
    }

    @Override
    public double convert(int f) throws RemoteException {
        return  ((f - 32)*5)/9;
    }
}
</code></pre>
<button class="v-markdown-it-code-copy" title="Sao chép" data-clipboard-text="import java.io.Serializable;
import java.rmi.RemoteException;

/**
 * Created by tranducliem on 3/26/16.
 */
public class RMICalculimpl implements RMICalcul, Serializable {
    @Override
    public int add(int a, int b) throws RemoteException {
        return a + b;
    }

    @Override
    public int sub(int a, int b) throws RemoteException {
        return a - b;
    }

    @Override
    public double convert(int f) throws RemoteException {
        return  ((f - 32)*5)/9;
    }
}
"></button>
<div class="v-content-flex-center"> </div>
</div>
<blockquote>
<p>Lưu ý: import thư viện trước khi sử dụng <code>java.io.Serializable</code> và <code>java.rmi.RemoteException</code></p>
</blockquote>
<p><strong>Tiếp theo chúng ta sẽ tạo một server có nhiệm vụ lắng nghe khi client call method</strong></p>
<div class="v-markdown-content-box" style="box-sizing: border-box; max-height: 300px; padding-bottom: 1rem; cursor: pointer; mask-image: linear-gradient(#000000 60%, transparent); color: #1b1b1b; font-family: 'Open Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol'; font-size: 18px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: #ffffff; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; position: relative;">
<pre class="language-java" data-filename=""><code>/**
 * Created by tranducliem on 3/26/16.
 */

import java.rmi.*;

public class CalculServer {
    public static void main(String[] args){
        try{
            // Load the service
            RMICalculimpl calculService = new RMICalculimpl();
            String res = "rmi://localhost/RMICalcul";

            // Register with service
            Naming.rebind(res, calculService);
        } catch(Exception e){
            System.err.println("Error: " + e.getMessage());
        }
    }
}
</code></pre>
<button class="v-markdown-it-code-copy" title="Sao chép" data-clipboard-text="/**
 * Created by tranducliem on 3/26/16.
 */

import java.rmi.*;

public class CalculServer {
    public static void main(String[] args){
        try{
            // Load the service
            RMICalculimpl calculService = new RMICalculimpl();
            String res = &quot;rmi://localhost/RMICalcul&quot;;

            // Register with service
            Naming.rebind(res, calculService);
        } catch(Exception e){
            System.err.println(&quot;Error: &quot; + e.getMessage());
        }
    }
}
"></button>
<div class="v-content-flex-center"> </div>
</div>
<p><code>Đến đây chúng ta đã tạm thời hoàn thành phần tạo server để lắng nghe khi client gọi đến. Tuy nhiên để client có thể gọi được thì đăng ký trong registry như sau:</code></p>
<div style="box-sizing: border-box; color: #1b1b1b; font-family: 'Open Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol'; font-size: 18px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: #ffffff; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; position: relative;">
<pre class="language-terminal" data-filename=""><code>rmiregistry &amp;
</code></pre>
<button class="v-markdown-it-code-copy" title="Sao chép" data-clipboard-text="rmiregistry &amp;
"></button></div>
<blockquote>
<p>Lưu ý: trước khi chạy lệnh trên thì toàn bộ class của chúng ta phải được <code>Compile</code> để compile bằng dòng lệnh chúng ta sử dụng <code>javac &lt;tên_file&gt;</code> hoặc có thể dùng luôn IDE để complie toàn bộ file</p>
</blockquote>
<blockquote>
<p>Thêm một vấn đề cần lưu ý tại đây: <code>rmiregistry &amp;</code> với lệnh này thì port sẽ được hệ thống tự động gen ra nếu muốn chủ động fix cổng thì chúng ta chỉ việc sử dụng <code>rmiregistry &lt;port&gt; &amp;</code> ví dụ: <code>rmiregistry 2016 &amp;</code>. Và nếu bạn sử dụng môi trường window thì dùng lệnh <code>start rmiregistry</code> thay cho lệnh <code>rmiregistry &amp;</code></p>
</blockquote>
<p>Sau khi đã đăng ký thì chúng ta sẽ genarate những file cần thiết cho việc remote đến server, sử dụng lệnh sau:</p>
<div style="box-sizing: border-box; color: #1b1b1b; font-family: 'Open Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol'; font-size: 18px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: #ffffff; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; position: relative;">
<pre class="language-terminal" data-filename=""><code>rmic -vcompat RMICalculimpl
</code></pre>
<button class="v-markdown-it-code-copy" title="Sao chép" data-clipboard-text="rmic -vcompat RMICalculimpl
"></button></div>
<p>hệ thống sẽ tự động sinh ra 2 file <code>RMICalculimpl_Skel.class</code> và <code>RMICalculimpl_Stub.class</code> ở project nào cần remote thì chúng ta sẽ import 2 file này vào. <strong>Ở đây tôi sẽ tạo class test trên cùng 1 project nên không cần copy</strong></p>
<p><code>Sau khi đã tạo ra những file cần thiết cho việc chạy thì chúng ta sẽ start server bằng lệnh:</code></p>
<div style="box-sizing: border-box; color: #1b1b1b; font-family: 'Open Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol'; font-size: 18px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: #ffffff; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; position: relative;">
<pre class="language-terminal" data-filename=""><code>java CalculServer
</code></pre>
<button class="v-markdown-it-code-copy" title="Sao chép" data-clipboard-text="java CalculServer
"></button></div>
<p><strong>Như vậy là server đã running và chờ đợi remote từ ứng dụng khác.</strong></p>
<h4>Tạo mới một class Client để test server vừa tạo</h4>
<p>Để test server remote vừa tạo tôi sẽ tạo một class <code>CalculClient</code> trong file <code>CalculClient.java</code> cùng thư mục hiện hành:</p>
<div class="v-markdown-content-box" style="box-sizing: border-box; max-height: 300px; padding-bottom: 1rem; cursor: pointer; mask-image: linear-gradient(#000000 60%, transparent); color: #1b1b1b; font-family: 'Open Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol'; font-size: 18px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: #ffffff; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; position: relative;">
<pre class="language-java" data-filename=""><code>/**
 * Created by tranducliem on 3/26/16.
 */

import java.rmi.*;

public class CalculClient {
    public static void main(String[] args){
        try{
            String res = "rmi://localhost/RMICalcul";
            // Lookup the service in the registry, and obtain a remote service
            Remote remoteService = Naming.lookup (res);

            // Cast to a RMICalcul Interface
            RMICalcul calculService = (RMICalcul)remoteService;

            // Call remote method
            System.out.println("Sum of 3 and 5 is: " + calculService.add(3,5));
            System.out.println("Sub of 5 and 3 is: " + calculService.sub(5,3));
            System.out.println("Convert 100 fahrenheit to Celsius: " + calculService.convert(100));
        } catch(Exception e){
            System.err.println("Error – " + e.getMessage());
        }
    }
}
</code></pre>
<button class="v-markdown-it-code-copy" title="Sao chép" data-clipboard-text="/**
 * Created by tranducliem on 3/26/16.
 */

import java.rmi.*;

public class CalculClient {
    public static void main(String[] args){
        try{
            String res = &quot;rmi://localhost/RMICalcul&quot;;
            // Lookup the service in the registry, and obtain a remote service
            Remote remoteService = Naming.lookup (res);

            // Cast to a RMICalcul Interface
            RMICalcul calculService = (RMICalcul)remoteService;

            // Call remote method
            System.out.println(&quot;Sum of 3 and 5 is: &quot; + calculService.add(3,5));
            System.out.println(&quot;Sub of 5 and 3 is: &quot; + calculService.sub(5,3));
            System.out.println(&quot;Convert 100 fahrenheit to Celsius: &quot; + calculService.convert(100));
        } catch(Exception e){
            System.err.println(&quot;Error – &quot; + e.getMessage());
        }
    }
}
"></button>
<div class="v-content-flex-center"> </div>
</div>
<p>Sau khi tạo xong tôi compile file <code>CalculClient.java</code> bằng lệnh:</p>
<div style="box-sizing: border-box; color: #1b1b1b; font-family: 'Open Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol'; font-size: 18px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: #ffffff; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; position: relative;">
<pre class="language-terminal" data-filename=""><code>javac CalculClient.java
</code></pre>
<button class="v-markdown-it-code-copy" title="Sao chép" data-clipboard-text="javac CalculClient.java
"></button></div>
<p>Sau khi compile xong thì hệ thống sẽ biên dịch code ra file <code>CalculClient.class</code> file này sẽ dùng để chạy</p>
<p>tất cả những file sau khi compile sẽ như sau:</p>
<figure class="article-img"><img loading="lazy"  src="https://images.viblo.asia/32140ae7-5bbc-4261-818a-fbe7bac17cf9.png" alt="Selection_042.png" data-is-external-image="true"></figure>
<p>để test chương trình chúng ta chạy lệnh sau trên terminal:</p>
<div style="box-sizing: border-box; color: #1b1b1b; font-family: 'Open Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol'; font-size: 18px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: #ffffff; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; position: relative;">
<pre class="language-terminal" data-filename=""><code>java CalculClient
</code></pre>
<button class="v-markdown-it-code-copy" title="Sao chép" data-clipboard-text="java CalculClient
"></button></div>
<p>Và chúng ta có kết qủa như sau:</p>
<figure class="article-img"><img loading="lazy"  src="https://images.viblo.asia/fbe03dd4-49e4-468a-8ce7-6b780c536719.png" alt="Selection_044.png" data-is-external-image="true"></figure>
<p>Như vậy chúng ta vừa tạo xong một ứng dụng đơn gỉản để remote mothod sử dụng RMI của Java. <em>Bài viết có tham khảo tài liệu của oracle:</em> <a href="https://docs.oracle.com/javase/tutorial/rmi/overview.html" target="_blank" rel="noopener">tại đây</a></p>
<p> </p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Chương 8: Lập trình multicast</title>
        <author>
            <name>Trần Huy Phương</name>
        </author>
        <link href="https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-8-lap-trinh-multicast/"/>
        <id>https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-8-lap-trinh-multicast/</id>

        <updated>2024-12-27T19:36:22+07:00</updated>
            <summary>
                <![CDATA[
                    Multicast là gì? Multicast được nhận biết là một hình thức truyền thông quan trọng, nó mang lại nhiều ưu điểm cho con người trong quá trình sử dụng. Đây là một thuật ngữ tương đối phức tạp thuộc lĩnh vực công nghệ thông tin. Bài&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p><strong><a href="https://vinahost.vn/multicast-la-gi/">Multicast là gì</a>?</strong> Multicast được nhận biết là một hình thức truyền thông quan trọng, nó mang lại nhiều ưu điểm cho con người trong quá trình sử dụng. Đây là một thuật ngữ tương đối phức tạp thuộc lĩnh vực công nghệ thông tin. Bài viết sau đây của <a href="https://vinahost.vn/">VinaHost</a> sẽ đề cập đến khái niệm Multicast, cách nó hoạt động, cũng như những ứng dụng của Multicast trong đời sống hằng ngày.</p>
<h2 id="ftoc-heading-1" class="ftwp-heading"><strong>1. Multicast là gì?</strong></h2>
<blockquote>
<p>Multicast là cách mà người gửi thông tin có thể truyền dữ liệu đến một nhóm người nhận trong cùng một lúc.</p>
</blockquote>
<p>Phương thức này cho phép một người truyền thông tin đến nhiều người nhận hoặc từ nhiều người gửi đến nhiều người nhận trong cùng một khoảng thời gian. Điều này giúp giảm tải cho mạng LAN bằng cách giảm khung dữ liệu được truyền đi.</p>
<blockquote>
<p><strong>Xem thêm:<a href="https://vinahost.vn/mang-lan-la-gi/"> [Tìm Hiểu] Mạng LAN Là Gì? So Sánh Mạng LAN, WAN và MAN</a></strong></p>
</blockquote>
<h2 id="ftoc-heading-2" class="ftwp-heading"><strong>2. IP Multicast là gì ?</strong></h2>
<p>Multicast trên<a href="https://vinahost.vn/internet-la-gi/"> internet</a> thường được biết đến với tên gọi là IP Multicasting. Điều này tuân thủ theo <a href="https://vinahost.vn/ip-la-gi/">giao thức internet (IP)</a> với mục đích chính là truyền tải dữ liệu.</p>
<p>Hệ thống IP Multicasting được xây dựng trên cơ sở của “Multicast Trees,” hay cây phát đa hướng, nhằm mục đích truyền tải thông tin giữa các thành viên trong mạng. Trong hệ thống này, một đường truyền duy nhất được phân nhánh đến vị trí của các người nhận trong nhóm.</p>
<p>Trong quá trình hoạt động, IP Multicast sử dụng hai giao thức chính là IGMP, tức là giao thức quản lý nhóm internet, và PIM – một giao thức phát đa hướng hoạt động độc lập. Trong hệ thống này, IGMP cấp quyền truy cập thông tin và dữ liệu cho người nhận một cách thoải mái. Bộ định tuyến mạng sẽ sử dụng PIM để tạo ra các Multicast Trees.</p>
<figure id="attachment_55516" class="wp-caption aligncenter" aria-describedby="caption-attachment-55516"><figure class="wp-image-55516 size-full entered litespeed-loaded"><img loading="lazy"  src="https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi.jpg" sizes="(max-width: 2000px) 100vw, 2000px" srcset="https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi.jpg 2000w, https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi-600x400.jpg 600w, https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi-1199x800.jpg 1199w, https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi-768x512.jpg 768w, https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi-1536x1025.jpg 1536w" alt="multicast la gi" width="2000" height="1334" data-lazyloaded="1" data-src="https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi.jpg" data-srcset="https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi.jpg 2000w, https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi-600x400.jpg 600w, https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi-1199x800.jpg 1199w, https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi-768x512.jpg 768w, https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi-1536x1025.jpg 1536w" data-sizes="(max-width: 2000px) 100vw, 2000px" data-ll-status="loaded" data-is-external-image="true"></figure>
<figcaption id="caption-attachment-55516" class="wp-caption-text">Multicast là cách mà người gửi thông tin có thể truyền dữ liệu đến một nhóm người nhận trong cùng một lúc</figcaption>
</figure>
<blockquote>
<p><strong>Xem thêm: <a href="https://vinahost.vn/igmp-la-gi/">IGMP là gì? Đặc điểm và những loại thông điệp của IGMP</a></strong></p>
</blockquote>
<h2 id="ftoc-heading-3" class="ftwp-heading"><strong>3. Cách thức hoạt động của Multicast</strong></h2>
<p>Multicast là một phương thức truyền thông trong mạng máy tính mà một nguồn có thể gửi dữ liệu đến một nhóm người nhận trong mạng. Dưới đây là cách thức hoạt động cơ bản:</p>
<ul>
<li aria-level="1"><strong>Người Gửi (Server):</strong> Người gửi là thiết bị hoặc ứng dụng gửi dữ liệu đến một nhóm người nhận cụ thể. Người gửi chọn một địa chỉ IP thuộc phạm vi địa chỉ Multicast để xác định nhóm người nhận.</li>
<li aria-level="1"><strong>Người Nhận (Client):</strong> Người nhận là các thiết bị hoặc ứng dụng mong muốn nhận dữ liệu từ người gửi. Người nhận tham gia vào nhóm bằng cách sử dụng giao thức như IGMP (Internet Group Management Protocol) để thông báo rằng chúng muốn tham gia vào nhóm.</li>
<li aria-level="1"><strong>Địa Chỉ IP Multicast:</strong> Địa chỉ IP Multicast là địa chỉ đặc biệt được sử dụng để xác định nhóm người nhận. Đối với <a href="https://vinahost.vn/ipv4-la-gi/">IPv4</a>, địa chỉ này nằm trong dải từ 224.0.0.0 đến 239.255.255.255. Đối với<a href="https://vinahost.vn/ipv6-la-gi/"> IPv6</a>, sẽ có một loạt các địa chỉ đặc trưng.</li>
<li aria-level="1"><strong>Router và Multicast Trees: </strong>Khi dữ liệu được gửi từ người gửi, router trong mạng sẽ sử dụng giao thức PIM (Protocol Independent Multicast) để xây dựng các cây phát đa hướng (Multicast Trees). Các cây này xác định đường truyền dữ liệu từ nguồn đến các người nhận trong nhóm.</li>
<li aria-level="1"><strong>IGMP (Internet Group Management Protocol):</strong> Giao thức này được sử dụng để quản lý và theo dõi thành viên của nhóm. Người nhận sử dụng IGMP để thông báo cho router biết rằng chúng muốn tham gia hoặc rời khỏi nhóm.</li>
<li aria-level="1"><strong>Phân phối Dữ liệu: </strong>Router sẽ phân phối dữ liệu theo các đường truyền đã được xác định bởi Multicast Trees. Dữ liệu chỉ được truyền đến các thành viên trong nhóm, giảm tải trên mạng so với việc sử dụng unicast hoặc broadcast.</li>
</ul>
<blockquote>
<p><strong>Xem thêm: <a href="https://vinahost.vn/client-server-la-gi/">Client Server là gì? | Tổng quan về mô hình Client Server</a></strong></p>
</blockquote>
<h2 id="ftoc-heading-4" class="ftwp-heading"><strong>4. Ưu và nhược điểm của Multicast</strong></h2>
<p>Phương thức này có những ưu nhược điểm nổi bật như sau.</p>
<h3 id="ftoc-heading-5" class="ftwp-heading"><strong>4.1. Ưu điểm của Multicast</strong></h3>
<p>Phương thức này đem đến nhiều ưu điểm xuất sắc, trong đó đáng chú ý nhất là khả năng ổn định cao. Cách tiếp cận này cho phép truyền dữ liệu đến một lượng lớn người nhận mà không ảnh hưởng đến hiệu suất mạng hay gây quá tải cho máy chủ.</p>
<p>Một điểm mạnh khác của phương thức này là khả năng tiết kiệm <a href="https://vinahost.vn/bang-thong-la-gi/">băng thông</a> đáng kể trong mạng viễn thông. Khi sử dụng Multicast, người gửi chỉ cần gửi một luồng dữ liệu duy nhất cho nhiều người nhận khác nhau, tránh việc phải truyền hàng loạt luồng dữ liệu cùng một lúc, từ đó giảm áp lực về băng thông.</p>
<p>Đồng thời, phương thức này giúp giảm thiểu tình trạng tải CPU trên máy trạm. Bằng cách nhận diện và loại bỏ dữ liệu không cần thiết tại tầng liên kết dữ liệu của<a href="https://vinahost.vn/may-tram-la-gi/"> máy trạm</a>, Multicast giảm bớt gánh nặng đối với <a href="https://vinahost.vn/cpu-la-gi/">CPU</a>, mang lại hiệu suất tối ưu.</p>
<h3 id="ftoc-heading-6" class="ftwp-heading"><strong>4.2. Nhược điểm của Multicast</strong></h3>
<p>Ngoài những lợi ích kể trên, Multicast vẫn mang những hạn chế cụ thể. Đầu tiên, có thể kể đến là nguy cơ nghẽn mạng. Do cơ chế của TCP Window không tương thích với giao thức UDP, làm cho Multicast có thể gây ra tình trạng tắc nghẽn mạng.</p>
<p>Thêm vào đó, đôi khi phương thức này gửi các gói tin mạng trùng lặp do hệ thống này vẫn đang được tiếp tục nghiên cứu để phát triển</p>
<h2 id="ftoc-heading-7" class="ftwp-heading"><strong>5. 2 cách sử dụng chính của mạng Multicast</strong></h2>
<p>Người dùng sẽ dựa vào một số đặc điểm cơ bản để xác định cách thức sử dụng. Dưới đây là hai ứng dụng chính thường thấy:</p>
<h3 id="ftoc-heading-8" class="ftwp-heading"><strong>5.1. Phân phối luồng dữ liệu AV</strong></h3>
<p>Phương thức này được sử dụng chủ yếu để phân phối luồng dữ liệu AV (Audio-Visual) hiệu quả trong môi trường mạng. Mạng Multicast cho phép việc truyền phát dữ liệu AV trực tiếp đến một nhóm người xem mà không cần phải tạo ra nhiều phiên bản riêng biệt của luồng dữ liệu cho từng người xem. Điều này giúp giảm tải cho hệ thống mạng và tăng cường hiệu suất phân phối.  </p>
<p>Dưới đây là một số cách chính mà mạng Multicast được áp dụng trong việc phân phối luồng dữ liệu AV:</p>
<ul>
<li aria-level="1">Truyền phát video trực tiếp (live streaming)</li>
<li aria-level="1">Hội nghị trực tuyến (online conferences)</li>
<li aria-level="1">Phát sóng truyền hình và nội dung giải trí</li>
<li aria-level="1">Đàm thoại trực tuyến và trò chơi đa người chơi</li>
<li aria-level="1">Phân phối nội dung trong doanh nghiệp</li>
</ul>
<h3 id="ftoc-heading-9" class="ftwp-heading"><strong>5.2. Cung cấp dữ liệu thị trường chứng khoán realtime</strong></h3>
<p>Trong tình huống này, để đảm bảo sự minh bạch trong thị trường, tất cả các người tham gia cần nhận thông tin đồng nhất cùng một lúc, vì vậy việc sử dụng Multicast là một phương tiện lý tưởng để phân phối dữ liệu.</p>
<p>Tuy nhiên, vấn đề mất gói tin cũng khá nghiêm trọng, đặc biệt là khi chúng mang theo thông tin quan trọng về giá cả và giao dịch. Vì thế, những luồng dữ liệu này cần được kết hợp với các hệ thống khác để khôi phục dữ liệu mất thông qua giao thức unicast TCP tiêu chuẩn.</p>
<p>Ngoài ra, phương thức này cũng được ứng dụng trong trường hợp chơi game trực tuyến, khi mà thông tin về trò chơi cần được phân phối đến một số lượng lớn người chơi trong thời gian thực.</p>
<blockquote>
<p><strong>Xem thêm: <a href="https://vinahost.vn/tcp-ip-la-gi/">TCP/IP là gì? | Chức năng của 4 tầng trong TCP/IP</a></strong></p>
</blockquote>
<h2 id="ftoc-heading-10" class="ftwp-heading"><strong>6. Một số vấn đề cơ bản với mạng Multicast</strong></h2>
<p>Có hai vấn đề cơ bản khi triển khai các luồng dữ liệu:</p>
<p>Đầu tiên, là cách để người nhận đăng ký nhận dữ liệu mà họ mong muốn và cách hủy đăng ký dữ liệu mà họ không muốn tiếp tục nhận nữa.</p>
<p>Thứ hai, là làm thế nào để chuyển tiếp các gói từ <a href="https://vinahost.vn/server-la-gi/">máy chủ</a> đến tất cả các máy thu sao cho mỗi gói chỉ được chuyển tiếp một lần và chỉ một lần, không phụ thuộc vào cách các thành phần kết nối với nhau.</p>
<p>Thường, hai vấn đề trên được giải quyết thông qua sử dụng hai giao thức dưới đây:</p>
<ul>
<li aria-level="1"><strong>Giao thức quản lý nhóm Internet (IGMP)</strong> được sử dụng để xử lý quá trình người nhận tham gia nhóm và rời khỏi nhóm.</li>
<li aria-level="1"><strong>Giao thức Multicast độc lập (PIM – Protocol Independent Multicast)</strong> là giao thức mà các thiết bị mạng Lớp 3 như bộ định tuyến sử dụng để xây dựng và quản lý cấu trúc cây phân phối đa hướng trên toàn mạng.</li>
</ul>
<h3 id="ftoc-heading-11" class="ftwp-heading"><strong>6.1. IMGP </strong></h3>
<p>Mặc dù các địa chỉ IP multicast hiển thị trong tiêu đề gói có vẻ giống các địa chỉ IPv4 hoặc IPv6 thông thường, thực tế chúng là các địa chỉ nhóm được sử dụng để tham chiếu đến tất cả các thành viên của nhóm tương ứng. Để tham gia nhóm, một thiết bị có thể gửi thông báo IGMP đến địa chỉ IP của nhóm. </p>
<figure id="attachment_55521" class="wp-caption aligncenter" aria-describedby="caption-attachment-55521"><figure class="wp-image-55521 size-full entered litespeed-loaded"><img loading="lazy"  src="https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi-1.jpg" sizes="(max-width: 1107px) 100vw, 1107px" srcset="https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi-1.jpg 1107w, https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi-1-800x294.jpg 800w, https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi-1-768x282.jpg 768w" alt="multicast la gi" width="1107" height="407" data-lazyloaded="1" data-src="https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi-1.jpg" data-srcset="https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi-1.jpg 1107w, https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi-1-800x294.jpg 800w, https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi-1-768x282.jpg 768w" data-sizes="(max-width: 1107px) 100vw, 1107px" data-ll-status="loaded" data-is-external-image="true"></figure>
<figcaption id="caption-attachment-55521" class="wp-caption-text">Để tham gia nhóm, một thiết bị có thể gửi thông báo IGMP đến địa chỉ IP của nhóm.</figcaption>
</figure>
<p>Bộ định tuyến Multicast trên mạng sẽ nhận được gói tin này và thực hiện các bước cần thiết để kích hoạt chuyển tiếp luồng dữ liệu đến thiết bị tham gia. Luôn luôn gửi các gói báo cáo thành viên IGMP với giá trị TTL là 1 nhằm đảm bảo rằng chúng không thể rời khỏi phân đoạn mạng hiện tại.</p>
<h3 id="ftoc-heading-12" class="ftwp-heading"><strong>6.2. IGMP snooping</strong></h3>
<p>IGMP snooping là một tính năng được triển khai trên các thiết bị chuyển mạch (switches) trong mạng để theo dõi và hiểu các gói tin IGMP được gửi từ các thiết bị đầu cuối. Khi bật IGMP snooping, switch có khả năng theo dõi giao tiếp IGMP và học được thông tin về việc tham gia và rời khỏi các nhóm IP Multicast.</p>
<p><strong>Vai trò của IGMP Snooping:</strong></p>
<ul>
<li aria-level="1"><strong>Lọc địa chỉ Multicast:</strong> IGMP snooping giúp switch biết được địa chỉ IP Multicast mà các thiết bị đầu cuối quan tâm. Switch chỉ chuyển tiếp lưu lượng đến các cổng mà có thiết bị nào đó đang tham gia nhóm, giảm thiểu lưu lượng truyền thông không cần thiết.</li>
<li aria-level="1"><strong>Tối ưu hóa băng thông: </strong>Thông qua việc lọc lưu lượng, IGMP snooping giúp tối ưu hóa băng thông mạng bằng cách giảm lưu lượng chuyển tiếp đi không đến các thiết bị không quan tâm đến nội dung Multicast.</li>
<li aria-level="1"><strong>Tránh đụng độ địa chỉ:</strong> Snooping giúp tránh việc chuyển tiếp đồng thời lưu lượng đến tất cả các cổng, giảm nguy cơ xảy ra đụng độ địa chỉ và tiêu tốn băng thông không cần thiết.</li>
</ul>
<figure id="attachment_55526" class="wp-caption aligncenter" aria-describedby="caption-attachment-55526"><figure class="wp-image-55526 size-full entered litespeed-loaded"><img loading="lazy"  src="https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi-2.jpg" sizes="(max-width: 892px) 100vw, 892px" srcset="https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi-2.jpg 892w, https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi-2-800x376.jpg 800w, https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi-2-768x361.jpg 768w" alt="multicast la gi" width="892" height="419" data-lazyloaded="1" data-src="https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi-2.jpg" data-srcset="https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi-2.jpg 892w, https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi-2-800x376.jpg 800w, https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi-2-768x361.jpg 768w" data-sizes="(max-width: 892px) 100vw, 892px" data-ll-status="loaded" data-is-external-image="true"></figure>
<figcaption id="caption-attachment-55526" class="wp-caption-text">IGMP snooping</figcaption>
</figure>
<h3 id="ftoc-heading-13" class="ftwp-heading"><strong>6.3. PIM</strong></h3>
<p>Do các gói báo cáo thành viên IGMP luôn có giá trị TTL là 1, chúng không thể được sử dụng để xác định nguồn trên một phân đoạn mạng khác. Để thực hiện điều này, thường người ta áp dụng PIM (Giao thức Đa phương thức Độc lập).</p>
<p>PIM (Protocol Independent Multicast) là một giao thức được sử dụng trong mạng Multicast để quản lý và điều phối lưu lượng qua các đường dẫn khác nhau. PIM là “độc lập với giao thức mạng” vì nó không phụ thuộc vào một giao thức định hình mạng cụ thể. PIM có thể hoạt động trên nhiều loại mạng, bao gồm IP, IPv6, và mạng không kết nối (disjointed networks).</p>
<p><strong>Vai trò của PIM:</strong></p>
<ul>
<li aria-level="1"><strong>Xác định đường dẫn Multicast:</strong> PIM giúp xác định đường dẫn tối ưu để truyền phát lưu lượng từ nguồn đến các nhóm mà có đầu cuối quan tâm.</li>
<li aria-level="1"><strong>Quản lý nút phân phối (Routers):</strong> PIM hoạt động trên các router để quản lý và chuyển tiếp lưu lượng qua mạng.</li>
<li aria-level="1"><strong>Chuyển tiếp lưu lượng thông minh: </strong>PIM chỉ chuyển tiếp lưu lượng đến những nơi có đầu cuối thực sự quan tâm, giảm lưu lượng không cần thiết và tối ưu hóa sử dụng băng thông.</li>
</ul>
<p><strong>Chế độ hoạt động:</strong></p>
<ul>
<li aria-level="1"><strong>PIM Dense Mode (PIM-DM): </strong>Chế độ này giả sử rằng tất cả các thiết bị đầu cuối đều quan tâm đến lưu lượng Multicast. Nó truyền phát lưu lượng đến tất cả các đường dẫn.</li>
<li aria-level="1"><strong>PIM Sparse Mode (PIM-SM): </strong>Chế độ này giả định rằng chỉ có một số ít các đầu cuối quan tâm đến lưu lượng Multicast. Nó yêu cầu có một trung tâm phân phối (Rendezvous Point – RP) để quản lý và điều phối lưu lượng đến các đường dẫn mà có đầu cuối quan tâm.</li>
</ul>
<figure id="attachment_55531" class="wp-caption aligncenter" aria-describedby="caption-attachment-55531"><figure class="wp-image-55531 size-full entered litespeed-loaded"><img loading="lazy"  src="https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi-3.jpg" sizes="(max-width: 845px) 100vw, 845px" srcset="https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi-3.jpg 845w, https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi-3-800x346.jpg 800w, https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi-3-768x332.jpg 768w" alt="multicast la gi" width="845" height="365" data-lazyloaded="1" data-src="https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi-3.jpg" data-srcset="https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi-3.jpg 845w, https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi-3-800x346.jpg 800w, https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi-3-768x332.jpg 768w" data-sizes="(max-width: 845px) 100vw, 845px" data-ll-status="loaded" data-is-external-image="true"></figure>
<figcaption id="caption-attachment-55531" class="wp-caption-text">PIM là một giao thức được sử dụng trong mạng Multicast để quản lý và điều phối lưu lượng qua các đường dẫn khác nhau.</figcaption>
</figure>
<h3 id="ftoc-heading-14" class="ftwp-heading"><strong>6.4. Rendezvous Point</strong></h3>
<p>Trong mạng Multicast, Rendezvous Point (RP) là một thành phần quan trọng của giao thức PIM-SM (Protocol Independent Multicast – Sparse Mode). RP được sử dụng để quản lý và điều phối lưu lượng từ nguồn đến các nhóm mà có đầu cuối quan tâm trong mô hình Sparse Mode. Dưới đây là mô tả chi tiết về Rendezvous Point:</p>
<p><strong>Vai trò của Rendezvous Point (RP)</strong></p>
<ul>
<li aria-level="1"><strong>Trung tâm phân phối:</strong> RP đóng vai trò như một trung tâm phân phối cho lưu lượng trong mô hình PIM-SM. Nó giữ thông tin về các nhóm và quản lý cách lưu lượng được chuyển tiếp từ nguồn đến các nhóm này.</li>
<li aria-level="1"><strong>Quyết định đường dẫn: </strong>RP quyết định đường dẫn tối ưu để truyền phát lưu lượng Multicast từ nguồn đến các nhóm mà có ít nhất một đầu cuối quan tâm.</li>
</ul>
<p><strong>Cách hoạt động của Rendezvous Point</strong></p>
<ul>
<li aria-level="1"><strong>Đăng ký nhóm Multicast:</strong> Các router trong mạng đăng ký với RP để thông báo về sự quan tâm của chúng đến các nhóm cụ thể. RP giữ thông tin về các nhóm và các router đăng ký với nó.</li>
<li aria-level="1"><strong>Phân phối lưu lượng: </strong>Khi có lưu lượng từ nguồn, RP quyết định đường dẫn tối ưu để phân phối lưu lượng đến các router và đầu cuối quan tâm.</li>
</ul>
<figure id="attachment_55536" class="wp-caption aligncenter" aria-describedby="caption-attachment-55536"><figure class="wp-image-55536 size-full entered litespeed-loaded"><img loading="lazy"  src="https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi-4.jpg" sizes="(max-width: 850px) 100vw, 850px" srcset="https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi-4.jpg 850w, https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi-4-800x345.jpg 800w, https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi-4-768x332.jpg 768w" alt="multicast la gi" width="850" height="367" data-lazyloaded="1" data-src="https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi-4.jpg" data-srcset="https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi-4.jpg 850w, https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi-4-800x345.jpg 800w, https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi-4-768x332.jpg 768w" data-sizes="(max-width: 850px) 100vw, 850px" data-ll-status="loaded" data-is-external-image="true"></figure>
<figcaption id="caption-attachment-55536" class="wp-caption-text">Rendezvous Point</figcaption>
</figure>
<blockquote>
<p><strong>Xem thêm: <a href="https://vinahost.vn/network-la-gi/">Network là gì? | [SO SÁNH] giữa Internet và Network</a></strong></p>
</blockquote>
<h2 id="ftoc-heading-15" class="ftwp-heading"><strong>7. Các giao thức định tuyến của Multicast là gì?</strong></h2>
<h3 id="ftoc-heading-16" class="ftwp-heading"><strong>7.1. Distance Vector Multicast Routing Protocol (DVMRP)</strong></h3>
<p>Distance Vector Multicast Routing Protocol (DVMRP) là một giao thức định tuyến Multicast sử dụng cơ chế vector khoảng cách để quảng bá thông tin định tuyến giữa các router trong mạng. DVMRP được thiết kế để hỗ trợ việc chuyển tiếp lưu lượng qua các mạng IP. </p>
<h3 id="ftoc-heading-17" class="ftwp-heading"><strong>7.2. Protocol Independent Multicast (PIM)</strong></h3>
<p>Protocol Independent Multicast (PIM) là một giao thức định tuyến Multicast được thiết kế để hỗ trợ việc chuyển tiếp lưu lượng trong mạng IP. Tên gọi “Protocol Independent” xuất phát từ khả năng của PIM trong việc hoạt động độc lập với các giao thức định tuyến Unicast khác, chẳng hạn như <a href="https://vi.wikipedia.org/wiki/Routing_Information_Protocol#:~:text=RIP%20(ti%E1%BA%BFng%20Anh%3A%20Routing%20Information,gi%E1%BB%AFa%20c%C3%A1c%20b%E1%BB%99%20%C4%91%E1%BB%8Bnh%20tuy%E1%BA%BFn." rel="nofollow noopener" target="_blank">RIP (Routing Information Protocol)</a> hoặc OSPF (Open Shortest Path First). PIM được phát triển để mang lại tính linh hoạt và tương thích rộng rãi trong môi trường định tuyến Multicast.</p>
<h3 id="ftoc-heading-18" class="ftwp-heading"><strong>7.3. Multicast Open Shortest Path First (MOSPF)</strong></h3>
<p>Multicast Open Shortest Path First (MOSPF) là một phần mở rộng của giao thức định tuyến <a href="https://vinahost.vn/ospf-la-gi/">OSPF (Open Shortest Path First)</a>. MOSPF kết hợp tính năng của OSPF với khả năng định tuyến Multicast, giúp quản lý và chuyển tiếp hiệu quả lưu lượng trong môi trường mạng.</p>
<blockquote>
<p><strong>Xem thêm: <a href="https://vinahost.vn/mang-may-tinh-la-gi/">Mạng máy tính là gì? Lợi ích và Phân loại Mạng máy tính</a></strong></p>
</blockquote>
<h2 id="ftoc-heading-19" class="ftwp-heading"><strong>8. Các ứng dụng của Multicast</strong></h2>
<p>Phương thức này đang được ứng dụng trong đa dạng lĩnh vực như sau:</p>
<ul>
<li aria-level="1"><strong>Thị trường chứng khoán:</strong> Multicast được sử dụng để truyền thông tin thị trường và hiển thị những thông tin này trên bảng điện.</li>
<li aria-level="1"><strong>Biển quảng cáo điện tử:</strong> Người quản trị có thể thay đổi nội dung của các biển quảng cáo thông qua mạng Multicast bằng cách truyền dữ liệu hình ảnh. </li>
<li aria-level="1"><strong>Truyền hình internet (IPTV):</strong> Giao thức này đang được sử dụng rộng rãi trong việc truyền tải nội dung truyền hình đến người xem qua mạng lưới IP. Người gửi nội dung truyền hình có thể truyền dữ liệu trong một luồng phát sóng duy nhất thay vì sử dụng nhiều luồng khác nhau cho từng người xem như Unicast.</li>
</ul>
<h2 id="ftoc-heading-20" class="ftwp-heading"><strong>9. Phân biệt điểm khác nhau giữa Unicast, Multicast và Broadcast</strong></h2>
<p>Bên cạnh Multicast, còn tồn tại các phương thức giao tiếp phổ biến khác như Unicast và Broadcast. Dưới đây là điểm khác nhau giữa Unicast, Multicast và Broadcast.</p>
<table>
<tbody>
<tr>
<td> </td>
<td><strong>Multicast</strong></td>
<td><strong>Unicast</strong></td>
<td><strong>Broadcast</strong></td>
</tr>
<tr>
<td>Đặc điểm</td>
<td>Multicast cho phép một nguồn truyền thông tin đến một nhóm người nhận cụ thể. Gói tin được gửi đến một địa chỉ multicast và được chia sẻ với nhóm người nhận.</td>
<td>Unicast là phương thức truyền thông giữa một nguồn và một đích duy nhất. Mỗi gói tin được gửi từ một nguồn và chỉ dành cho một đích cụ thể.</td>
<td>Broadcast là phương thức truyền thông mà một nguồn gửi thông tin đến tất cả các thiết bị trong mạng.</td>
</tr>
<tr>
<td>Cách thức tương tác</td>
<td>Tương tác diễn ra giữa một người gửi và rất nhiều người nhận cùng lúc.</td>
<td>Tương tác chỉ diễn ra giữa một người gửi và một người nhận.</td>
<td>Tương tác diễn ra giữa một người gửi và tất cả người nhận khả dụng.</td>
</tr>
<tr>
<td>Cách thức hoạt động </td>
<td>Dữ liệu được luân chuyển khi nhận yêu cầu từ những người nhận cùng lúc. </td>
<td>Dữ liệu chỉ được luân chuyển khi nhận yêu cầu từ một người nhận duy nhất.</td>
<td>Dữ liệu được luân chuyển cho tất cả người nhận bất kể có yêu cầu nhận hay không.</td>
</tr>
<tr>
<td>Độ bảo mật</td>
<td>Độ bảo mật tương đối vì dữ liệu được gửi đến một nhóm người nhận nhất định.</td>
<td>Độ bảo mật cao nhất vì dữ liệu được gửi đến một đích đến độc nhất.</td>
<td>Độ bảo mật thấp do dữ liệu được gửi đến tất cả thiết bị trong mạng lưới.</td>
</tr>
<tr>
<td>Độ trễ </td>
<td>Có độ trễ trung bình</td>
<td>Có độ trễ thấp</td>
<td>Có độ trễ cao</td>
</tr>
<tr>
<td>Ứng dụng</td>
<td>Phù hợp cho việc truyền thông tin đến một nhóm người nhận cụ thể, giảm tải băng thông so với Unicast khi có nhiều người nhận.</td>
<td>Thích hợp cho truyền thông điểm đến điểm, nơi chỉ có một người nhận thông tin.</td>
<td>Thường được sử dụng trong các mạng cục bộ (LAN) để chia sẻ thông điệp với tất cả các thiết bị trong mạng.</td>
</tr>
</tbody>
</table>
<p>Tóm lại:</p>
<ul>
<li aria-level="1">Unicast dành cho truyền thông từ một nguồn đến một đích cụ thể.</li>
<li aria-level="1">Multicast được sử dụng để truyền thông tin đến một nhóm người nhận cụ thể.</li>
<li aria-level="1">Broadcast gửi thông điệp đến tất cả các thiết bị trong mạng.</li>
</ul>
<figure id="attachment_55541" class="wp-caption aligncenter" aria-describedby="caption-attachment-55541"><figure class="wp-image-55541 size-full entered litespeed-loaded"><img loading="lazy"  src="https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi-5.jpg" sizes="(max-width: 1234px) 100vw, 1234px" srcset="https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi-5.jpg 1234w, https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi-5-800x373.jpg 800w, https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi-5-768x358.jpg 768w" alt="multicast la gi" width="1234" height="576" data-lazyloaded="1" data-src="https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi-5.jpg" data-srcset="https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi-5.jpg 1234w, https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi-5-800x373.jpg 800w, https://vinahost.vn/wp-content/uploads/2024/03/multicast-la-gi-5-768x358.jpg 768w" data-sizes="(max-width: 1234px) 100vw, 1234px" data-ll-status="loaded" data-is-external-image="true"></figure>
<figcaption id="caption-attachment-55541" class="wp-caption-text">Phân biệt điểm khác nhau giữa Unicast, Multicast và Broadcast</figcaption>
</figure>
<h2 id="ftoc-heading-21" class="ftwp-heading"><strong>10. Hướng dẫn cách tạo Multicast trên mạng máy tính </strong></h2>
<p>Nếu bạn muốn phát triển một ứng dụng đa hướng trên mạng cục bộ của riêng mình, có ba cách mà bạn có thể lựa chọn để thực hiện:</p>
<h3 id="ftoc-heading-22" class="ftwp-heading"><strong>10.1. Local scope</strong></h3>
<p>Để tạo Multicast trên mạng máy tính với phạm vi cục bộ (Local scope), bạn có thể sử dụng địa chỉ IP Multicast thuộc dải địa chỉ đặc biệt cho phạm vi cục bộ. Một trong những dải phổ biến là 239.0.0.0 đến 239.255.255.255. Đảm bảo rằng bạn chọn một địa chỉ không xung đột với các địa chỉ khác trong mạng của bạn. </p>
<p>Tùy thuộc vào ứng dụng bạn đang sử dụng, bạn cần cấu hình nó để sử dụng địa chỉ IP Multicast bạn đã chọn. Điều này có thể bao gồm cấu hình địa chỉ Multicast trong mã nguồn của ứng dụng hoặc trong tùy chọn cấu hình.</p>
<p>Nếu bạn đang tạo một ứng dụng Multicast trong môi trường mạng cục bộ, việc sử dụng IGMP là quan trọng. Sau khi cấu hình, kiểm tra kết nối và giám sát lưu lượng trong mạng của bạn. Sử dụng công cụ như Wireshark để theo dõi gói tin và đảm bảo rằng chúng đang được chuyển tiếp đúng cách.</p>
<h3 id="ftoc-heading-23" class="ftwp-heading"><strong>10.2. Giải quyết GLOP</strong></h3>
<p>Dưới đây là hướng dẫn cách tạo Multicast, sử dụng phương pháp GLOP trên mạng máy tính:</p>
<p><strong>Chọn BGP ASN:</strong></p>
<p>Chọn một BGP ASN (Autonomous System Number) để sử dụng trong quá trình tạo GLOP. ASN này cần được đăng ký và duy trì bởi tổ chức của bạn.</p>
<p><strong>Chọn dải địa chỉ IP Multicast:</strong></p>
<p>Chọn dải địa chỉ IP Multicast trong phạm vi GLOP. Phạm vi thông thường là 233.0.0.0/8. Mã hóa BGP ASN vào địa chỉ IP Multicast trong dải này để tạo địa chỉ IP Multicast GLOP.</p>
<p><strong>Mã hóa BGP ASN vào địa chỉ Multicast:</strong></p>
<p>Sử dụng BGP ASN đã chọn và mã hóa nó vào địa chỉ IP Multicast trong dải GLOP. Cách thức mã hóa như sau:</p>
<ul>
<li aria-level="1">Bảng chuyển đổi BGP ASN thành hai byte.</li>
<li aria-level="1">Ghép hai byte này vào địa chỉ Multicast 233.x.x.x/8, trong đó x là giá trị của hai byte đó.</li>
</ul>
<p>Ví dụ: Nếu BGP ASN của bạn là 65525, bạn sẽ mã hóa nó thành hai byte là 255 và 245. Ghép chúng vào địa chỉ 233.255.245.0/24.</p>
<p><strong>Cấu hình Router BGP:</strong></p>
<p>Cấu hình router sử dụng BGP với BGP ASN bạn đã chọn. Cài đặt BGP để chuyển tiếp thông tin định tuyến Multicast sử dụng địa chỉ IP Multicast GLOP.</p>
<p><strong>Kiểm tra và giám sát:</strong></p>
<p>Sau khi cấu hình, kiểm tra và giám sát lưu lượng sử dụng địa chỉ IP Multicast GLOP. Sử dụng các công cụ giám sát mạng như Wireshark để theo dõi gói tin.</p>
<p>Lưu ý rằng việc sử dụng GLOP đòi hỏi sự hiểu biết vững về BGP và cấu trúc địa chỉ IP Multicast. Ngoài ra, đảm bảo kiểm tra tính tương thích và hỗ trợ BGP trên các thiết bị mạng của bạn.</p>
<h3 id="ftoc-heading-24" class="ftwp-heading"><strong>10.3. Các địa chỉ được chỉ định thường xuyên</strong></h3>
<p>Và phương pháp thứ ba để đạt được việc cấp phát địa chỉ vĩnh viễn trong các dải 224.0.2.0-224.0.255.0 và 224.1.0.0-224.1.255.255 là thông qua việc đăng ký tại IANA. Tuy nhiên, những địa chỉ này hiện đang có nguồn tài nguyên khá hạn chế. Do đó, phương pháp này chỉ nên được thực hiện khi bạn có một ứng dụng phát Multicast mà bạn dự định chia sẻ với một số lượng lớn người nhận.</p>
<blockquote>
<p><strong>Xem thêm: <a href="https://vinahost.vn/1-1-1-1-la-gi/">1.1.1.1 là gì | Hướng dẫn cách Cài Đặt &amp; Thay Đổi DNS 1.1.1.1</a></strong></p>
</blockquote>
<h2 id="ftoc-heading-25" class="ftwp-heading"><strong>11. Tổng kết</strong></h2>
<p>Bài viết đã đề cập chi tiết về Multicast là gì, bao gồm cả khái niệm, ưu nhược điểm, và ứng dụng nổi bật của nền tảng này. Sự quan trọng của phương thức này là không thể phủ nhận trong thực tế hiện nay, đặc biệt khi mạng lưới internet đang ngày càng mở rộng mạnh mẽ.</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Chương 7: Lập trình socket cho giao thức UDP</title>
        <author>
            <name>Trần Huy Phương</name>
        </author>
        <link href="https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-7-lap-trinh-socket-cho-giao-thuc-udp/"/>
        <id>https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-7-lap-trinh-socket-cho-giao-thuc-udp/</id>

        <updated>2024-12-27T19:35:18+07:00</updated>
            <summary>
                <![CDATA[
                    1. Lập tình socket với UDP Đầu tiên, UDP là viết tắt của User Datagram Protocol. UDP được giới thiệu vào năm 1980 và là một trong những giao thức mạng lâu đời nhất còn được sử dụng. UDP được sử dụng cho những đường&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <h3>1. Lập tình socket với UDP</h3>
<p><img loading="lazy" src="https://s3-sgn09.fptcloud.com/codelearnstorage/Media/Default/Users/TrisDo/socket2/sth.png" alt="" width="575" height="247" data-is-external-image="true"></p>
<p>Đầu tiên, UDP là viết tắt của User Datagram Protocol. UDP được giới thiệu vào năm 1980 và là một trong những giao thức mạng lâu đời nhất còn được sử dụng. UDP được sử dụng cho những đường truyền yêu cầu tốc độ cao và thời gian ngắn như video playback, game stream, game online, hay được sử dụng để tìm kiếm trong hệ thống tên miền (DNS). Giao thức này giúp tăng tốc độ truyền tải vì nó không yêu cầu kết nối giữa máy gửi và máy nhận trước khi 2 phía có thể trao đổi thông điệp. Chính điều này UDP cung cấp đường truyền không tin cậy bằng gói dữ liệu/datagrams (group of bytes) trong khi đó TCP cung cấp đường truyền tin cậy bằng dòng byte, vì vậy UDP socket và TCP socket cũng có những khác biệt cơ bản.</p>
<p><img loading="lazy" src="https://s3-sgn09.fptcloud.com/codelearnstorage/Media/Default/Users/TrisDo/socket2/sth2.png" alt="" width="551" height="329" data-is-external-image="true"></p>
<p>Với UDP socket, chúng ta không cần thiết lập liên kết “handshaking” giữa client và server trước khi truyền thông điệp, thông điệp được gửi đi một cách độc lập. Bên gửi sẽ chỉ rõ địa chỉ IP và số hiệu cổng (port number) của bên nhận. Sau khi thông điệp được truyền đến bên nhận, bện nhận có thể dựa vào địa chỉ IP và số hiệu cổng tương ứng của bên gửi được gắn trên gói tin để gửi lại response.</p>
<p>Chúng ta có thể thấy rằng việc truyền bằng gói tin có thể làm dữ liệu truyền đến không theo thứ tự hoặc bị mất, thêm nữa UDP không cung cấp chức năng kiểm soát lỗi, mất gói tin nhưng một phần lợi ích của việc truyền bằng gói tin chính là tốc độ và thời gian.</p>
<p>Trước khi lập tình socket UDP chúng ta cần biết quy trình hoạt động của mỗi bên client và server, giữa client và server của UDP socket có ít khác biệt hơn so với TCP socket.</p>
<p>  <img loading="lazy" src="https://s3-sgn09.fptcloud.com/codelearnstorage/Media/Default/Users/TrisDo/socket2/sth3.png" alt="" width="544" height="355" data-is-external-image="true"></p>
<p>Với UDP ta không cần thiết lập liên kết 2 chiều giữa client và server.</p>
<p>Về phía client:</p>
<ul>
<li>Cần biết được địa chỉ IP cũng như số hiệu cổng của phía Server</li>
<li>Mỗi gói tin gửi đi cần có địa chỉ IP, số hiệu cổng của nơi gửi đến, nơi gửi đi</li>
<li>Gửi gói tin cho server</li>
</ul>
<p>Pseudo code cho client:</p>
<p>               Tạo socket</p>
<p>               Gửi gói tin đến địa chỉ của server</p>
<p>               Nhận gói tin đã xử lý từ server</p>
<p>               Đóng socket</p>
<p>Về phía server: nhận gói tin, trích xuất địa chỉ IP, số hiệu cổng của client, xử lý và respond gói tin lại cho client.</p>
<p> Pseudo code cho server:</p>
<p>               Tạo socket</p>
<p>               Ràng buộc socket với 1 số hiệu cổng mà client sẽ truyền đến</p>
<p>               Vòng lặp:</p>
<p>                              Nhận gói tin từ client</p>
<p>                              Gửi gói tin đã xử lý cho client</p>
<p>               Đóng socket</p>
<p>Bên trên là hoạt động ở phía client và phía server, sau đây là một ví dụ đơn giản ứng dụng UDP socket.</p>
<h3>2. Mô phỏng UDP socket với Java Code</h3>
<p>Mô tả ví dụ:</p>
<ul>
<li>Client đọc dòng văn bản nhập từ bàn phím người dùng , gửi gói tin tới địa chỉ của server</li>
<li>Server nhận gói tin từ client</li>
<li>Server sẽ chuyển lại dòng văn bản kèm theo “Server accepted” thông qua 1 gói tin mới tới địa chỉ của client</li>
<li>Client đọc dòng văn bản từ gói tin và in ra dòng văn bản nhận được từ server.</li>
</ul>
<p>Trong ví dụ  này mình dùng công cụ Netbeans IDE và class DatagramSocket, DatagramPacket, InetAddress của Java. Sau đây là file java phía server:</p>
<pre class="language-java" tabindex="0"><code>package UDPsocket;
import java.net.DatagramSocket;
import java.net.DatagramPacket;
import java.net.InetAddress;
public class serverUDP {
    
    public static void main(String args[]) throws Exception { 
        //Tạo socket phía server với số hiệu cổng 9876
        DatagramSocket serverSocket = new DatagramSocket(9876);   
        while(true) { 
            //tạo biến receiveData để nhận dữ liệu từ gói tin đến 
            byte[] receiveData = new byte[1024];
            //tạo sendData để nhận dữ liệu gửi lên gói tin đi
            byte[] sendData  = new byte[2048];
//            
            //tạo biến receivePacket để nhận gói tin từ socket
            DatagramPacket receivePacket = 
                    new DatagramPacket(receiveData, receiveData.length); 
            //nhận gói tin qua phương thức receive()
            serverSocket.receive(receivePacket);
            //Chuyển dữ liệu vừa nhận về dạng String
            String sentence = new String(receivePacket.getData()); 
 //           
            //Lấy địa chỉ IP của bên gửi
            InetAddress IPAddress = receivePacket.getAddress();
            //Lấy số hiệu cổng bên gửi
            int port = receivePacket.getPort(); 
            //Xử lý dữ liệu vừa nhận
            String sentence_to_client = sentence+ " (server accpeted!)"; 
            
            //tạo gói tin để gửi đi client
            sendData = sentence_to_client.getBytes();
            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, IPAddress, port);
            //Gửi gói tin đi
            serverSocket.send(sendPacket); 
        } 
    } 
}</code></pre>
<p><strong>Đầu tiên</strong> tạo 1 socket bên server với số cổng, các bạn có thể chọn ngẫu nhiên, ở đây mình để 9876.</p>
<p><strong>Tiếp đến</strong> trong vòng lặp while khởi tạo 2 mảng kiểu byte là receiveData và sendData để chứa dữ liệu đến, dữ liệu đi.</p>
<p><strong>Tạo gói tin</strong> receivePacket với 2 tham số là receiveData và độ dài của receiveData (1024) để nhận gói tin truyền đến. Mình dùng phương thức receive() để nhận gói tin từ socket.</p>
<p><strong>Tạo biến</strong> String sentence để lấy dữ liệu trong gói tin qua phương thức getData(), biến IPAddress để lưu địa chỉ IP của client, biến port để lưu số hiệu cổng của phía client.</p>
<p>Biến sentence_to_client được xử lý và đưa vào mảng sendData bằng phương thức getBytes().</p>
<p><strong>Tiếp đến</strong> tạo một gói tin mới để truyền đi phía client, như đã nói ở trên thì 1 gói tin truyền đi cần có dữ liệu, địa chỉ IP và số hiệu cổng của bên nhận. Do đó tham số tryền vào ở đây là mảng chứa dữ liệu sendData, độ dài dữ liệu, địa chỉ IP và số hiệu cổng của client mà mình lấy được từ gói tin truyền đến bên trên.</p>
<p><strong>Cuối cùng</strong> gửi gói tin lên socket qua phương thức send().</p>
<p>Ở đây mình không tạo điều liện kết thúc vòng lặp là để cho server luôn trong trạng thái chờ gói tin.</p>
<p>File java phía client:</p>
<pre class="language-java" tabindex="0"><code>package UDPsocket;
import java.io.*;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
public class clientUDP {
    public static void main(String args[]) throws Exception { 
        //tạo socket phía client
        DatagramSocket clientSocket = new DatagramSocket(6789); 
        //Tạo địa chỉ IP address bỏi tên "localhost)
        InetAddress IPAddress = InetAddress.getByName("localhost"); 
        
        while(true){
            //Tạo dữ liệu(group of bytes) cho gói tin nhận và gói tin gủi
            byte[] sendData = new byte[1024]; 
            byte[] receiveData = new byte[2048]; 
//         
            //lấy dòng văn bản nhập từ bàn phím và gán cho biến sentence
            BufferedReader inFromUser = 
                    new BufferedReader(new InputStreamReader(System.in)); 
            String sentence = inFromUser.readLine();
//            
            //tạo dữ liệu gửi với dữ liệu vừa nhập từ bàn phím
            sendData = sentence.getBytes();
            //Tạo gói tin để truyền đi
            DatagramPacket sendPacket = 
                    new DatagramPacket(sendData, sendData.length, IPAddress, 9876); 
            //Truyền đến server bằng phương thức send()
            clientSocket.send(sendPacket); 
//        
            //tạo gói tin nhận
            DatagramPacket receivePacket = 
                new DatagramPacket(receiveData, receiveData.length); 
            //lấy biến receivePacket để nhận gói tin bằng phương thức receive()
            clientSocket.receive(receivePacket); 
        
            //Chuyển dữu liệu trong gói tin vừa nhận thành kiểu String và in ra
            String modified_Sentence = new String(receivePacket.getData());
            System.out.println("FROM SERVER:" + modified_Sentence); 
            
            if(sentence.compareTo("quit") == 0) 
                break;
        }
        //Đóng socket
        clientSocket.close(); 
    } 
}</code></pre>
<p>Giống với phía server đầu tiên chúng ta cần tạo 1 socket phía client ràng buộc với 1 số hiệu cổng, sau đó tạo 1 biến IPAddress để lưu địa chỉ IP của phía server, vì ở đây mình lập trình server và client đều trên 1 máy nên tham số truyền vào là “localhost” hoặc “127.0.0.1”, máy tính sẽ tham chiếu đến chính nó.</p>
<p>Trong vòng lặp while, khởi tạo 2 mảng byte để chứa dữ liệu và 1 biến String để lấy dòng văn bản nhập từ bàn phím máy tính.</p>
<p>Tiếp theo, cũng giống với ben server lần lượt tạo 2 gói sendData và receiveData để gửi và nhận, riêng với gói tin truyền đi sendPacket thì 4 tham số tuyền vào là mảng dữ liệu sendData, độ dài dữ liệu, địa chỉ IP và số hiệu cổng (9876) của server.</p>
<p>Sau khi server nhận được gói tin gửi đi từ phái client, xử lí và gửi lại gói tin mới cho client, phái client sẽ nhận gói tin bằng biến receivePacket uqa phương thức receive(), tiếp đến là chuyển dữ liệu vừa nhận sang kiểu String và in ra.</p>
<p>Cuối cùng vòng lặp while sẽ kết thúc khi nhập “quit” từ bàn phím, sau đó socket phía client sẽ được đóng với phương thức close().</p>
<h3>Kết quả</h3>
<p>Đây là kết quả khi chạy lần lượt 2 file trên:</p>
<p><img loading="lazy" src="https://s3-sgn09.fptcloud.com/codelearnstorage/Media/Default/Users/TrisDo/socket2/Annotation%202020-08-11%20131000.jpg" alt="" width="342" height="194" data-is-external-image="true"></p>
<h3>3. UDP khác TCP như thế nào?</h3>
<p>Như vậy các bạn vừa tìm hiểu xong về lập trình socket với UDP. Qua đó hình dung được sự khác nhau giữa 2 giao thức UDP và TCP.</p>
<p>UDP cho tốc độ nhanh, không tốn chi phí thiết lập liên kết nên phú hợp cho thông báo dữ liệu thời tiết, phát video trực tuyến, dịch vụ báo giá cổ phiếu (không dùng cho giao dịch) hoặc cho lưu lương đa luồng,…Trong khi đó, TCP cung cấp dịch vụ truyền dòng byte tin cậy thông qua việc thiết lập liên kết 2 chiều và có kiểm tra lỗi, mất dữ liệu nên phù hợp với việc truyền file, gửi email, tình duyệt web,…</p>
<p>Trước khi lập trình socket ta cần xác định giao thức nào phù hợp, UDP hay TCP và thuộc phía client hay server, phía client thì giả sử phía server đã hoạt động ta chỉ cần kết nối đến, còn phía server thì cần khởi động và chờ kết nối.</p>
<p>Các bạn có thể tìm hiểu lập tình socket cơ bản với TCP/IP tại đây: <a title="lap trinh socket java" rel="noopener" href="https://codelearn.io/sharing/lap-trinh-socket-co-voi-tcpip-ava" target="_blank">lap-trinh-socket-voi-TCP</a> </p>
<h3>Lời kết</h3>
<p>Qua bài này chúng ta đã tìm hiểu về lập tình Socket với UDP, sự khác nhau cơ bản giữa lập trình Socket UDP vs TCP và một vài khái niệm đơn giản về mạng máy tính. Bài viết này mình có tham khảo một số tài liệu của đại học Bách Khoa Hà Nội và đại học Cornell. Nếu có thắc mắc, bạn đọc vui lòng bình luận bên dưới để mọi người cùng giải đáp. Cảm ơn bạn đọc, chúc bạn đọc thành công trên con đường học tập!</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Chương 6: Kỹ thuật đa tiến trình và tuần tự hoá... Ứng dụng mạng</title>
        <author>
            <name>Trần Huy Phương</name>
        </author>
        <link href="https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-6-ky-thuat-da-tien-trinh-va-tuan-tu-hoa-ung-dung-mang/"/>
        <id>https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-6-ky-thuat-da-tien-trinh-va-tuan-tu-hoa-ung-dung-mang/</id>

        <updated>2024-12-27T19:33:57+07:00</updated>
            <summary>
                <![CDATA[
                    Kỹ Thuật Đa Tiến Trình và Tuần Tự Hoá: Ứng Dụng Mạng Trong thế giới lập trình hiện đại, việc xử lý các tác vụ phức tạp và tối ưu hóa hiệu suất hệ thống là điều không thể thiếu. Một trong những kỹ thuật&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <h3><strong>Kỹ Thuật Đa Tiến Trình và Tuần Tự Hoá: Ứng Dụng Mạng</strong></h3>
<p>Trong thế giới lập trình hiện đại, việc xử lý các tác vụ phức tạp và tối ưu hóa hiệu suất hệ thống là điều không thể thiếu. Một trong những kỹ thuật quan trọng trong việc này là <strong>đa tiến trình</strong> và <strong>tuần tự hoá đối tượng</strong>. Cùng tôi khám phá cách những kỹ thuật này có thể cải thiện hiệu suất ứng dụng mạng của bạn!</p>
<p>Trong lập trình, đặc biệt là khi xây dựng ứng dụng mạng, việc tối ưu hoá hiệu suất và đảm bảo tính ổn định là rất quan trọng. <strong>Đa tiến trình</strong> và <strong>tuần tự hoá đối tượng</strong> là hai kỹ thuật quan trọng giúp đạt được điều này. Hãy cùng tìm hiểu và xem các ví dụ về cách sử dụng chúng trong Java.</p>
<h4><strong>1. Đa Tiến Trình trong Java</strong></h4>
<p>Đa tiến trình cho phép bạn thực thi nhiều tác vụ đồng thời, giúp cải thiện hiệu suất và tốc độ phản hồi. Điều này đặc biệt quan trọng khi xây dựng các ứng dụng mạng cần xử lý nhiều tác vụ cùng một lúc.</p>
<h5><strong>Ví dụ minh hoạ: Đa Tiến Trình với Máy Chủ Đơn Giản trong Java</strong></h5>
<pre>import java.util.concurrent.ExecutorService;<br>import java.util.concurrent.Executors;<br><br>public class MultiThreadedServer {<br>    public static void main(String[] args) {<br>        ExecutorService executorService = Executors.newFixedThreadPool(5);  // Tạo một pool 5 tiến trình<br><br>        for (int i = 0; i &lt; 5; i++) {<br>            int requestId = i;<br>            executorService.submit(() -&gt; handleRequest(requestId));  // Gửi yêu cầu đến tiến trình xử lý<br>        }<br><br>        executorService.shutdown();  // Đóng executor service khi sử dụng xong<br>    }<br><br>    private static void handleRequest(int requestId) {<br>        System.out.println("Đang xử lý yêu cầu #" + requestId + " trong tiến trình " + Thread.currentThread().getName());<br>        try {<br>            Thread.sleep(2000);  // Giả lập thời gian xử lý yêu cầu<br>        } catch (InterruptedException e) {<br>            e.printStackTrace();<br>        }<br>        System.out.println("Yêu cầu #" + requestId + " đã hoàn thành.");<br>    }<br>}<br><br></pre>
<p><strong>Giải thích</strong>:</p>
<ul>
<li><strong>ExecutorService</strong> được sử dụng để quản lý pool các tiến trình.</li>
<li>Máy chủ sẽ xử lý đồng thời 5 yêu cầu, mỗi yêu cầu được xử lý bởi một tiến trình khác nhau.</li>
<li>Mỗi yêu cầu được giả lập xử lý với <code>Thread.sleep()</code>.</li>
</ul>
<h5><strong>Lợi ích của Đa Tiến Trình trong Java</strong>:</h5>
<ul>
<li><strong>Tăng hiệu suất</strong>: Xử lý đồng thời nhiều yêu cầu, giảm thiểu thời gian chờ đợi.</li>
<li><strong>Sử dụng tài nguyên hiệu quả</strong>: Tận dụng sức mạnh của các bộ vi xử lý đa lõi.</li>
<li><strong>Giảm độ trễ</strong>: Đặc biệt hữu ích trong các ứng dụng thời gian thực hoặc mạng.</li>
</ul>
<h4><strong>2. Tuần Tự Hoá Đối Tượng trong Java</strong></h4>
<p><strong>Tuần tự hoá đối tượng</strong> là quá trình chuyển đổi các đối tượng thành một chuỗi byte để có thể lưu trữ hoặc truyền tải qua mạng, sau đó phục hồi lại đối tượng khi cần thiết. Điều này rất quan trọng trong các ứng dụng mạng khi dữ liệu cần được truyền tải giữa các hệ thống khác nhau.</p>
<h5><strong>Ví dụ minh hoạ: Tuần Tự Hoá Đối Tượng trong Java</strong></h5>
<pre>import java.io.*;<br><br>class User implements Serializable {<br>    private String username;<br>    private String email;<br><br>    public User(String username, String email) {<br>        this.username = username;<br>        this.email = email;<br>    }<br><br>    public String getUsername() {<br>        return username;<br>    }<br><br>    public String getEmail() {<br>        return email;<br>    }<br><br>    @Override<br>    public String toString() {<br>        return "User{username='" + username + "', email='" + email + "'}";<br>    }<br>}<br><br>public class SerializationExample {<br>    public static void main(String[] args) {<br>        User user = new User("huyphuong", "huyphuong@example.com");<br><br>        // Tuần tự hoá đối tượng vào một tệp<br>        try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("user.ser"))) {<br>            out.writeObject(user);<br>            System.out.println("Đối tượng đã được tuần tự hoá: " + user);<br>        } catch (IOException e) {<br>            e.printStackTrace();<br>        }<br><br>        // Phục hồi đối tượng từ tệp<br>        try (ObjectInputStream in = new ObjectInputStream(new FileInputStream("user.ser"))) {<br>            User deserializedUser = (User) in.readObject();<br>            System.out.println("Đối tượng đã phục hồi: " + deserializedUser);<br>        } catch (IOException | ClassNotFoundException e) {<br>            e.printStackTrace();<br>        }<br>    }<br>}</pre>
<p><strong>Giải thích</strong>:</p>
<ul>
<li>Lớp <code>User</code> implements <code>Serializable</code> để có thể tuần tự hoá các đối tượng của lớp này.</li>
<li>Đối tượng <code>user</code> được tuần tự hoá vào tệp <code>user.ser</code>, sau đó phục hồi lại từ tệp này.</li>
<li>Kỹ thuật tuần tự hoá giúp truyền tải đối tượng qua mạng hoặc lưu trữ trạng thái của đối tượng.</li>
</ul>
<h5><strong>Lợi ích của Tuần Tự Hoá trong Java</strong>:</h5>
<ul>
<li><strong>Truyền tải dữ liệu</strong>: Tuần tự hoá đối tượng để có thể gửi qua mạng giữa các hệ thống.</li>
<li><strong>Lưu trữ trạng thái</strong>: Giúp lưu trữ trạng thái của đối tượng khi ứng dụng bị gián đoạn.</li>
<li><strong>Giao tiếp giữa các hệ thống</strong>: Có thể truyền tải dữ liệu qua các hệ thống khác nhau, kể cả những hệ thống không giống nhau về nền tảng.</li>
</ul>
<h4><strong>3. Kết Hợp Đa Tiến Trình và Tuần Tự Hoá trong Ứng Dụng Mạng</strong></h4>
<p>Bây giờ, chúng ta sẽ kết hợp cả <strong>đa tiến trình</strong> và <strong>tuần tự hoá</strong> để tạo ra một ứng dụng mạng, nơi nhiều tiến trình sẽ xử lý yêu cầu và tuần tự hoá dữ liệu để truyền tải.</p>
<h5><strong>Ví dụ Minh Hoạ: Máy Chủ Đa Tiến Trình với Tuần Tự Hoá trong Ứng Dụng Mạng</strong></h5>
<pre>import java.io.*;<br>import java.net.*;<br>import java.util.concurrent.ExecutorService;<br>import java.util.concurrent.Executors;<br><br>class User implements Serializable {<br>    private String username;<br>    private String email;<br><br>    public User(String username, String email) {<br>        this.username = username;<br>        this.email = email;<br>    }<br><br>    public String getUsername() {<br>        return username;<br>    }<br><br>    public String getEmail() {<br>        return email;<br>    }<br><br>    @Override<br>    public String toString() {<br>        return "User{username='" + username + "', email='" + email + "'}";<br>    }<br>}<br><br>public class NetworkServer {<br>    public static void main(String[] args) throws IOException {<br>        ServerSocket serverSocket = new ServerSocket(8080);<br>        ExecutorService executorService = Executors.newFixedThreadPool(5);  // Pool 5 tiến trình<br><br>        System.out.println("Server đang lắng nghe tại cổng 8080...");<br><br>        while (true) {<br>            Socket socket = serverSocket.accept();<br>            System.out.println("Khách hàng đã kết nối: " + socket.getInetAddress());<br><br>            executorService.submit(() -&gt; {<br>                try {<br>                    // Xử lý yêu cầu trong tiến trình riêng<br>                    ObjectInputStream input = new ObjectInputStream(socket.getInputStream());<br>                    User user = (User) input.readObject();<br>                    System.out.println("Nhận dữ liệu người dùng: " + user);<br><br>                    // Gửi lại dữ liệu tuần tự hoá cho khách hàng<br>                    ObjectOutputStream output = new ObjectOutputStream(socket.getOutputStream());<br>                    output.writeObject(new User("server_response", "response@example.com"));<br>                    System.out.println("Gửi phản hồi cho khách hàng.");<br><br>                    socket.close();<br>                } catch (IOException | ClassNotFoundException e) {<br>                    e.printStackTrace();<br>                }<br>            });<br>        }<br>    }<br>}</pre>
<p><strong>Giải thích</strong>:</p>
<ul>
<li>Máy chủ lắng nghe kết nối từ khách hàng trên cổng 8080.</li>
<li>Khi một khách hàng kết nối, máy chủ sẽ tạo một tiến trình mới để xử lý yêu cầu của khách hàng.</li>
<li>Dữ liệu từ khách hàng được tuần tự hoá và gửi lại thông qua mạng.</li>
</ul>
<hr>
<h3><strong>Kết Luận</strong></h3>
<p>Kết hợp <strong>đa tiến trình</strong> và <strong>tuần tự hoá đối tượng</strong> trong Java giúp bạn xây dựng các ứng dụng mạng hiệu quả và dễ mở rộng. Đa tiến trình giúp tăng cường khả năng xử lý đồng thời, trong khi tuần tự hoá giúp bạn truyền tải và lưu trữ dữ liệu một cách hiệu quả.</p>
<p>Cả hai kỹ thuật này đều rất quan trọng khi xây dựng các ứng dụng mạng hoặc hệ thống phân tán, và sẽ giúp bạn cải thiện hiệu suất và độ ổn định của ứng dụng.</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Chương 5: Lập trình socket cho giao thức TCP</title>
        <author>
            <name>Trần Huy Phương</name>
        </author>
        <link href="https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-5-lap-trinh-socket-cho-giao-thuc-tcp/"/>
        <id>https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-5-lap-trinh-socket-cho-giao-thuc-tcp/</id>

        <updated>2024-12-27T19:32:19+07:00</updated>
            <summary>
                <![CDATA[
                    Socket được biết đến là cánh cửa giao tiếp giữa hai tiến trình ứng dụng. Socket hỗ trợ nhiều ngôn ngữ (C, java, perl, python,…) cũng như nhiều platform (*nix, Windows,…). Socket được viết bằng các ngôn ngữ khác nhau và chạy trên bất kỳ&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p><strong>Socket được biết đến là cánh cửa giao tiếp giữa hai tiến trình ứng dụng. Socket hỗ trợ nhiều ngôn ngữ (C, java, perl, python,…) cũng như nhiều platform (*nix, Windows,…). Socket được viết bằng các ngôn ngữ khác nhau và chạy trên bất kỳ platform nào đều có thể giao tiếp với nhau. Trong bài viết này mình gửi đến các bạn khái niệm cơ bản về Socket cũng như cách lập trình Socket với các loại giao thức.</strong></p>
<h3><strong>1. Tổng quan về Socket</strong></h3>
<p>Trong hệ thống mạng máy tính tồn tại những mô hình tham chiếu có kiến trúc phần tầng (OSI, TCP/IP…) nhằm hỗ trợ chức năng trao đôi thông tin giữa các ứng dụng ở nhiều máy tính khác nhau.</p>
<h4><img loading="lazy" src="https://s3-sgn09.fptcloud.com/codelearnstorage/Media/Default/Users/tria3ltt_40gmail_2Ecom/socketJavaImage/Annotation%202020-08-08%20132406.jpg" alt="" width="625" height="265" data-is-external-image="true"></h4>
<p>Dữ liệu bên gửi sẽ được đóng gói (Encapsulation) từ tầng trên đến tầng cuối là tầng vật lí (Physical Layer), sau đó nhờ tầng vật lí này chuyển dữ liệu đến tầng vật lí máy bên nhận, bên nhận tiến hành giải mã (decapsulation) gói dữ kiện từ tầng dưới lên tầng trên cùng, là tầng ứng dụng (application layer).</p>
<p><img loading="lazy" src="https://s3-sgn09.fptcloud.com/codelearnstorage/Media/Default/Users/tria3ltt_40gmail_2Ecom/socketJavaImage/Annotation%202020-08-08%20160924.jpg" alt="" width="628" height="316" data-is-external-image="true"></p>
<p>Ở đây, Socket chính là cửa giao tiếp giữa tầng ứng dụng và tầng giao vận (Transport layer). Nói cách khác, Socket là giao diện do ứng dụng tạo ra trên máy trạm, quản lí bởi hệ điều hành qua đó các ứng dụng có thể gửi/nhận thông điệp đến/từ các ứng  dụng khác. Ở đó, Socket sẽ được ràng buộc với một mã số cổng (Port Number) để giúp tầng giao vận định danh được ứng dụng nhận/gửi thông điệp.</p>
<p>Các bạn có thể thấy ở hình ảnh trên, tầng giao vận có 2 phương thức là TCP (Ttransmission Control Protocol) và UDP (User Datagram Protocol), như vậy socket cơ bản là có 2 loại: Stream Socket sử dụng TCP truyền dòng bytes và Datagram Socket dử dụng UDP truyền gói tin. Với ngôn ngữ lập trình Java, chúng ta được cung cấp 3 loại khác nhau của sockets:</p>
<ol>
<li>Stream Socket (TCP) : Tạo luồng dữ liệu hai chiều, đáng tin cậy, có trình tự và không trùng lặp, dữ liệu chỉ được gửi/nhận khi có đã có liên kết. Dùng với Socket Class của java.</li>
<li>Datagram Socket (UDP): Có thể nhận dữ liệu không theo tình tự, trùng lặp. Dùng với DatagramSocket Class.</li>
<li>Multicast Socket : cho phép dữ liệu được gửi đến nhiều bên nhận một lúc. Dùng với DatagramSocket Class.</li>
</ol>
<p>Socket được hỗ trợ trên nhiều ngôn ngữ như C, Java, Pearl,  Python,…. Sau đây là một ví dụ lập tình socket với Java.</p>
<h3><strong>2. Lập trình TCP Socket với Java</strong></h3>
<p>Trong bài viết này mình sẽ nói về lập trình Socket sử dụng TCP.</p>
<p><img loading="lazy" src="https://s3-sgn09.fptcloud.com/codelearnstorage/Media/Default/Users/tria3ltt_40gmail_2Ecom/socketJavaImage/Annotation%202020-08-08%20160941.jpg" alt="" width="585" height="246" data-is-external-image="true"></p>
<p>Đúng như tính chất của TCP chúng ta cần có liên kết 2 chiều trước khi server và client có thể trao đổi thông điệp với nhau.</p>
<p>Ban đầu, phía server tạo Socket được ràng buộc với một cổng (port number) để chờ nhận yêu cầu từ phía client.</p>
<p>Tiếp đến phía client yêu cầu server bằng cách tạo một Socket TCP trên máy kèm với địa chỉ IP và port number của tiến tình tương ứng trên máy server. Khi client tạo Socket, client TCP tạo liên kết với server TCP và chờ chấp nhận kết nối từ server.</p>
<p>TCP cung cấp dịch vụ truyền dòng tin cậy và có thứ tự giữa client và server, giữa máy chủ và máy nhận chỉ có 1 địa chỉ IP duy nhất. Thêm vào đó, mỗi thông điệp truyền đi đều có xác nhận trả về.</p>
<p>Sau đây là một ví dụ ứng dụng đơn giản về lập trình TCP Socket với Java.</p>
<p>Miêu tả ứng dụng:</p>
<ul>
<li>Client đọc dòng văn bản nhập từ bàn phím người dùng , gửi tới server qua Socket</li>
<li>Server đọc các dòng văn bản gửi từ Socket</li>
<li>Server sẽ chuyển lại dòng văn bản kèm theo “Server accepted” tới phía client qua Socket</li>
<li>Client đọc dòng văn bản từ socket và in ra dòng văn bản nhận được từ server</li>
</ul>
<p><img loading="lazy" src="https://s3-sgn09.fptcloud.com/codelearnstorage/Media/Default/Users/tria3ltt_40gmail_2Ecom/socketJavaImage/Annotation%202020-08-08%20132421.jpg" alt="" width="557" height="370" data-is-external-image="true"></p>
<p>Chúng ta có thể thấy rằng mỗi phía server và client đều có 2 luồng dữ liệu, một luồng ra Socket để gửi thông điệp và một luồng vào từ Socket để nhận thông điệp, như vậy với mỗi bên mình có hai biến input và output (inFromServer, outToServer và inFromClient, outToClient).</p>
<p>Trong ví dụ này mình dùng công cụ NetBeans IDE  và Socket Class, serverSocket của Java. Sau đây là file java cho phía server:</p>
<pre class="language-java" tabindex="0"><code>package socket;
import java.io.*;
import java.net.Socket;
import java.net.ServerSocket;
public class serverTCP {
    public static void main(String argv[]) throws Exception
    {
        String sentence_from_client;
        String sentence_to_client;
        
        //Tạo socket server, chờ tại cổng '6543'
        ServerSocket welcomeSocket = new ServerSocket(6543);
        
        while(true) {
            //chờ yêu cầu từ client
            Socket connectionSocket = welcomeSocket.accept();
            
            //Tạo input stream, nối tới Socket
            BufferedReader inFromClient =
                new BufferedReader(new
                    InputStreamReader(connectionSocket.getInputStream())); 
            
            //Tạo outputStream, nối tới socket
            DataOutputStream outToClient =
                new DataOutputStream(connectionSocket.getOutputStream());
            
            //Đọc thông tin từ socket
            sentence_from_client = inFromClient.readLine();
            
            sentence_to_client = sentence_from_client +" (Server accepted!)" + '\n';
            //ghi dữ liệu ra socket
            outToClient.writeBytes(sentence_to_client); 
            return;
        }
        
    }
}</code></pre>
<p>Ở đây mình tạo 2 biến <code>String</code> để nhận và gửi dữ liệu cho/từ phía client, và một biến của ServerSocket để chờ liên kết từ phía client, với số cổng là một số ngẫu nhiên lớn hơn 1024 ( trong một số hệ thống yêu cầu đặc quyền quản trị để ràng buộc số cổng &lt; 1024), ở đây mình chọn 6543.</p>
<p>Tiếp theo trong vòng lặp <code>While</code> mình cho giá tị true để serversocket luôn chấp nhận liên kết từ client, các bạn có thể chèn thêm điều kiện dừng cho vòng lặp. Như đã nói ở trên mình sẽ tạo 1 socket connectionSocket để nhận một đối tượng socket từ server đồng thời chấp nhận liên kết từ client qua phương thức accept().</p>
<p>Sau đó là 2 biến inFromClient và outToClient để nhận và gửi dữ liệu lên socket.</p>
<p>Biến sentence_from_client sẽ lấy dòng văn bản được truyền từ phía client thông qua biến inFromClient, biến sentence_to_client được gán bằng biến sentence_from_client + “ (Server accepted!)”.</p>
<p>Biến sentence_to_client sẽ được chuyển lên Socket qua phương thức writeBytes().</p>
<p>Còn về phía client:</p>
<pre class="language-java" tabindex="0"><code>package socket;
import java.io.*;
import java.net.Socket;
public class clientTCP {
    public static void main(String argv[]) throws Exception
    {
        String sentence_to_server;
        String sentence_from_server;
    
        //Tạo Inputstream(từ bàn phím)
        System.out.print("Input from client: ");
        BufferedReader inFromUser =
            new BufferedReader(new InputStreamReader(System.in));
        //Lấy chuỗi ký tự nhập từ bàn phím
        sentence_to_server = inFromUser.readLine();
//    
        //Tạo socket cho client kết nối đến server qua ID address và port number
        Socket clientSocket = new Socket("127.0.0.1", 6543);
    
        //Tạo OutputStream nối với Socket
        DataOutputStream outToServer =
            new DataOutputStream(clientSocket.getOutputStream());
    
        //Tạo inputStream nối với Socket
        BufferedReader inFromServer =
            new BufferedReader(new
            InputStreamReader(clientSocket.getInputStream()));
//     
        //Gửi chuỗi ký tự tới Server thông qua outputStream đã nối với Socket (ở trên)
        outToServer.writeBytes(sentence_to_server + '\n');
    
        //Đọc tin từ Server thông qua InputSteam đã nối với socket
        sentence_from_server = inFromServer.readLine();
    
        //print kết qua ra màn hình
        System.out.println("FROM SERVER: " + sentence_from_server);
    
        //Đóng liên kết socket
        clientSocket.close();    
    } 
}</code></pre>
<p>Mình cũng có 2 biến String để nhận và gửi dòng văn bản. Nhận văn bản được nhập từ bàn phím cho biến sentence_to_server qua biến inFromUser.</p>
<p>Tiếp theo là tạo một socket bên client hướng liên kết tới địa chỉ IP “localhost” và cổng 6543 giống với số cổng Server, ở đây vì mình đang sử dụng trên một máy tính lên địa chỉ IP để là “localhost” hoặc “127.0.0.1”, máy tính sẽ tham chiếu tới chính nó.</p>
<p>Tạo 2 biến outToServer và inFomServer để nhận và gửi dữ liệu.</p>
<p>Biến sentence_to_server sẽ được chuyển lên socket để truyền tới server qua phương thức writeBytes().</p>
<p>Sau khi server nhận dòng văn bản, xử lí và chuyển lên socket, biến <code>sentence_from_server</code> sẽ nhận dòng văn bản đó thông qua phương thức readLine(). Cuối cùng chúng ta in ra dòng văn bản vừa nhận từ Server và đong socket bằng phương thức close().</p>
<p>Để chạy được ví dụ này chúng ta cần run file java phía server trước để thiết lập server socket, sau đó run file java phía client. Đây là kết quả sau khi chạy lần lượt 2 file trên.</p>
<p><img loading="lazy" src="https://s3-sgn09.fptcloud.com/codelearnstorage/Media/Default/Users/tria3ltt_40gmail_2Ecom/socketJavaImage/Annotation%202020-08-08%20163442.jpg" alt="" width="530" height="201" data-is-external-image="true"></p>
<h3>3. Lời kết</h3>
<p>Qua bài này, mình và các bạn đã tìm hiểu khái niệm về socket cũng như cách lập trình socket với TCP trong java. Về cơ bản lập trình Socket trong các ngôn ngữ lập trình khác không có nhiều khác biệt, việc viết các chương trình giao tiếp như vậy trong nhiều ngôn ngữ khác nhau giúp các bạn luyện tập tốt hơn trong quá trình học tập. Trong bài viết có nhiều thuật ngữ, khái niệm liên quan đến mạng máy tính, nếu có cơ hội mình sẽ viết trong các bài blog tiếp theo. Cảm ơn các bạn đọc. Chúc các bạn thành công trên con đường học tập!</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Chương 4: Quản lý địa chỉ kết nối mạng</title>
        <author>
            <name>Trần Huy Phương</name>
        </author>
        <link href="https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-4-quan-ly-dia-chi-ket-noi-mang/"/>
        <id>https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-4-quan-ly-dia-chi-ket-noi-mang/</id>

        <updated>2024-12-27T19:29:34+07:00</updated>
            <summary>
                <![CDATA[
                    Giới thiệu Trong lập trình Java, việc làm việc với địa chỉ mạng và URL rất quan trọng, đặc biệt khi xây dựng các ứng dụng mạng hoặc web. Java cung cấp hai lớp mạnh mẽ là InetAddress và URL trong gói java.net để hỗ&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <h2><strong>Giới thiệu</strong></h2>
<p>Trong lập trình Java, việc làm việc với địa chỉ mạng và URL rất quan trọng, đặc biệt khi xây dựng các ứng dụng mạng hoặc web. Java cung cấp hai lớp mạnh mẽ là <code>InetAddress</code> và <code>URL</code> trong gói <code>java.net</code> để hỗ trợ quản lý kết nối mạng, tra cứu DNS, và xử lý URL.</p>
<hr>
<h2><strong>Lớp InetAddress</strong></h2>
<p><code>InetAddress</code> là lớp đại diện cho địa chỉ IP, có thể là IPv4 hoặc IPv6. Lớp này cung cấp các phương thức để tra cứu địa chỉ IP và tên miền.</p>
<h3><strong>1. Các phương thức chính</strong></h3>
<ul>
<li><strong><code>getByName(String host)</code></strong>: Lấy địa chỉ IP của một tên miền hoặc host.</li>
<li><strong><code>getLocalHost()</code></strong>: Lấy địa chỉ IP của máy cục bộ.</li>
<li><strong><code>getAllByName(String host)</code></strong>: Lấy tất cả địa chỉ IP liên kết với một tên miền.</li>
<li><strong><code>getHostAddress()</code></strong>: Trả về địa chỉ IP dưới dạng chuỗi.</li>
<li><strong><code>getHostName()</code></strong>: Trả về tên host từ địa chỉ IP.</li>
</ul>
<h3><strong>2. Ví dụ sử dụng</strong></h3>
<div class="contain-inline-size rounded-md border-[0.5px] border-token-border-medium relative bg-token-sidebar-surface-primary dark:bg-gray-950">
<div class="flex items-center text-token-text-secondary px-4 py-2 text-xs font-sans justify-between rounded-t-md h-9 bg-token-sidebar-surface-primary dark:bg-token-main-surface-secondary select-none"> </div>
<div> </div>
<pre class="overflow-y-auto p-4" dir="ltr">import java.net.InetAddress;<br><br>public class InetAddressExample {<br>    public static void main(String[] args) {<br>        try {<br>            // Lấy địa chỉ IP từ tên miền<br>            InetAddress address = InetAddress.getByName("www.google.com");<br>            System.out.println("Host Name: " + address.getHostName());<br>            System.out.println("IP Address: " + address.getHostAddress());<br><br>            // Lấy địa chỉ IP của máy cục bộ<br>            InetAddress localAddress = InetAddress.getLocalHost();<br>            System.out.println("Local Host Name: " + localAddress.getHostName());<br>            System.out.println("Local IP Address: " + localAddress.getHostAddress());<br><br>        } catch (Exception e) {<br>            e.printStackTrace();<br>        }<br>    }<br>}</pre>
</div>
<p><strong>Kết quả:</strong></p>
<div class="contain-inline-size rounded-md border-[0.5px] border-token-border-medium relative bg-token-sidebar-surface-primary dark:bg-gray-950">
<div class="flex items-center text-token-text-secondary px-4 py-2 text-xs font-sans justify-between rounded-t-md h-9 bg-token-sidebar-surface-primary dark:bg-token-main-surface-secondary select-none"> </div>
<div class="sticky top-9 md:top-[5.75rem]">
<div class="absolute bottom-0 right-2 flex h-9 items-center">
<div class="flex items-center rounded bg-token-sidebar-surface-primary px-2 font-sans text-xs text-token-text-secondary dark:bg-token-main-surface-secondary"> </div>
</div>
</div>
<div class="overflow-y-auto p-4" dir="ltr">Host Name: www.google.com  <br>IP Address: 142.250.74.196  <br>Local Host Name: MyComputer  <br>Local IP Address: 192.168.1.2  </div>
</div>
<hr>
<h2><strong>Lớp URL</strong></h2>
<p><code>URL</code> là lớp đại diện cho địa chỉ tài nguyên trên Internet (Uniform Resource Locator). Lớp này được sử dụng để phân tích cú pháp URL và kết nối tới tài nguyên qua giao thức như HTTP, FTP.</p>
<h3><strong>1. Các thành phần của URL</strong></h3>
<p>Một URL điển hình có dạng:</p>
<div class="contain-inline-size rounded-md border-[0.5px] border-token-border-medium relative bg-token-sidebar-surface-primary dark:bg-gray-950">
<div class="flex items-center text-token-text-secondary px-4 py-2 text-xs font-sans justify-between rounded-t-md h-9 bg-token-sidebar-surface-primary dark:bg-token-main-surface-secondary select-none"> </div>
<div class="overflow-y-auto p-4" dir="ltr"><code class="!whitespace-pre hljs language-bash">protocol://host:port/path?query<span class="hljs-comment">#fragment</span>
</code></div>
</div>
<ul>
<li><strong>protocol:</strong> Giao thức (HTTP, HTTPS, FTP, v.v.).</li>
<li><strong>host:</strong> Tên miền hoặc địa chỉ IP.</li>
<li><strong>port:</strong> Cổng giao tiếp (mặc định 80 cho HTTP, 443 cho HTTPS).</li>
<li><strong>path:</strong> Đường dẫn tới tài nguyên.</li>
<li><strong>query:</strong> Tham số truyền qua URL.</li>
<li><strong>fragment:</strong> Thẻ đánh dấu bên trong tài liệu.</li>
</ul>
<h3><strong>2. Các phương thức chính</strong></h3>
<ul>
<li><strong><code>getProtocol()</code></strong>: Lấy giao thức của URL.</li>
<li><strong><code>getHost()</code></strong>: Lấy tên miền hoặc địa chỉ IP của URL.</li>
<li><strong><code>getPort()</code></strong>: Lấy số cổng (nếu không có, trả về -1).</li>
<li><strong><code>getPath()</code></strong>: Lấy đường dẫn tài nguyên.</li>
<li><strong><code>getQuery()</code></strong>: Lấy chuỗi truy vấn (query string).</li>
<li><strong><code>getFile()</code></strong>: Lấy đường dẫn tài nguyên kèm query.</li>
<li><strong><code>openConnection()</code></strong>: Mở kết nối tới URL.</li>
</ul>
<h3><strong>3. Ví dụ sử dụng</strong></h3>
<div class="contain-inline-size rounded-md border-[0.5px] border-token-border-medium relative bg-token-sidebar-surface-primary dark:bg-gray-950">
<div class="flex items-center text-token-text-secondary px-4 py-2 text-xs font-sans justify-between rounded-t-md h-9 bg-token-sidebar-surface-primary dark:bg-token-main-surface-secondary select-none"> </div>
<div class="sticky top-9 md:top-[5.75rem]">
<div class="absolute bottom-0 right-2 flex h-9 items-center">
<div class="flex items-center rounded bg-token-sidebar-surface-primary px-2 font-sans text-xs text-token-text-secondary dark:bg-token-main-surface-secondary"> </div>
</div>
</div>
<pre class="overflow-y-auto p-4" dir="ltr">import java.net.URL;<br><br>public class URLExample {<br>    public static void main(String[] args) {<br>        try {<br>            // Khởi tạo URL<br>            URL url = new URL("https://www.example.com:8080/path/to/resource?user=test#section1");<br><br>            // Lấy thông tin từ URL<br>            System.out.println("Protocol: " + url.getProtocol());<br>            System.out.println("Host: " + url.getHost());<br>            System.out.println("Port: " + url.getPort());<br>            System.out.println("Path: " + url.getPath());<br>            System.out.println("Query: " + url.getQuery());<br>            System.out.println("File: " + url.getFile());<br>            System.out.println("Ref: " + url.getRef());<br><br>        } catch (Exception e) {<br>            e.printStackTrace();<br>        }<br>    }<br>}</pre>
</div>
<p><strong>Kết quả:</strong></p>
<div class="contain-inline-size rounded-md border-[0.5px] border-token-border-medium relative bg-token-sidebar-surface-primary dark:bg-gray-950">
<div class="sticky top-9 md:top-[5.75rem]">
<div class="absolute bottom-0 right-2 flex h-9 items-center">
<div class="flex items-center rounded bg-token-sidebar-surface-primary px-2 font-sans text-xs text-token-text-secondary dark:bg-token-main-surface-secondary"> </div>
</div>
</div>
<div class="overflow-y-auto p-4" dir="ltr">Protocol: https  <br>Host: www.example.com  <br>Port: 8080  <br>Path: /path/to/resource  <br>Query: user=test  <br>File: /path/to/resource?user=test  <br>Ref: section1  </div>
</div>
<hr>
<h2><strong>So sánh InetAddress và URL</strong></h2>
<table>
<thead>
<tr>
<th>Đặc điểm</th>
<th>InetAddress</th>
<th>URL</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Chức năng chính</strong></td>
<td>Quản lý địa chỉ IP</td>
<td>Quản lý URL và tài nguyên trên Internet</td>
</tr>
<tr>
<td><strong>Giao thức hỗ trợ</strong></td>
<td>Không phụ thuộc giao thức</td>
<td>Hỗ trợ HTTP, HTTPS, FTP, v.v.</td>
</tr>
<tr>
<td><strong>Sử dụng</strong></td>
<td>Tra cứu địa chỉ IP, tên miền</td>
<td>Phân tích URL và truy cập tài nguyên</td>
</tr>
<tr>
<td><strong>Kết nối tài nguyên</strong></td>
<td>Không hỗ trợ</td>
<td>Hỗ trợ thông qua <code>openConnection()</code></td>
</tr>
</tbody>
</table>
<hr>
<h2><strong>Ứng dụng thực tế</strong></h2>
<ol>
<li><strong>Tra cứu DNS:</strong> Sử dụng <code>InetAddress</code> để lấy địa chỉ IP từ tên miền.</li>
<li><strong>Phân tích URL:</strong> Dùng <code>URL</code> để xử lý các liên kết phức tạp trong ứng dụng web.</li>
<li><strong>Tích hợp API:</strong> Kết hợp <code>URL</code> với <code>HttpURLConnection</code> để giao tiếp với các dịch vụ web.</li>
</ol>
<hr>
<h2><strong>Kết luận</strong></h2>
<p>Lớp <code>InetAddress</code> và <code>URL</code> trong Java là hai công cụ mạnh mẽ giúp bạn xử lý địa chỉ mạng và tài nguyên trực tuyến dễ dàng. Tùy vào mục đích cụ thể (quản lý địa chỉ IP hoặc phân tích URL), bạn có thể lựa chọn lớp phù hợp.</p>
<p>Hy vọng bài viết này giúp bạn hiểu rõ hơn và áp dụng hiệu quả trong các dự án của mình! 😊</p>
<p>Nếu cần hỗ trợ thêm hoặc muốn chia sẻ ý kiến, hãy để lại bình luận!</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Chương 3: Lập trình đa tuyến</title>
        <author>
            <name>Trần Huy Phương</name>
        </author>
        <link href="https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-3-lap-trinh-da-tuyen/"/>
        <id>https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-3-lap-trinh-da-tuyen/</id>

        <updated>2024-12-27T19:28:21+07:00</updated>
            <summary>
                <![CDATA[
                    Lập trình đa luồng (Multi-threading) là một kỹ thuật trong lập trình mà một ứng dụng có thể thực thi nhiều phần công việc (luồng – thread) một cách đồng thời. Trong Java, đa luồng là một tính năng mạnh mẽ và quan trọng, giúp các&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p><strong>Lập trình đa luồng</strong> (Multi-threading) là một kỹ thuật trong lập trình mà một ứng dụng có thể thực thi nhiều phần công việc (luồng – thread) một cách đồng thời. Trong Java, đa luồng là một tính năng mạnh mẽ và quan trọng, giúp các ứng dụng có thể tận dụng tối đa tài nguyên CPU và giảm thời gian xử lý bằng cách thực thi nhiều tác vụ cùng lúc.</p>
<p>Java cung cấp hỗ trợ sẵn có cho lập trình đa luồng thông qua lớp <strong><code class=" prettyprinted"><span class="typ">Thread</span></code></strong> và giao diện <strong><code class=" prettyprinted"><span class="typ">Runnable</span></code></strong>. Việc sử dụng đa luồng trong Java giúp tăng cường hiệu suất và cải thiện tính đáp ứng (responsiveness) của ứng dụng, đặc biệt trong các ứng dụng yêu cầu xử lý song song hoặc thời gian thực.</p>
<h2 id="khai-niem-thread-trong-java" class="ftwp-heading">Khái niệm thread trong Java</h2>
<h3 id="thread-la-gi" class="ftwp-heading"><span id="Thread_la_gi_Multi-thread_la_gi">Thread là gì?</span></h3>
<p><strong>Thread</strong> (luồng) về cơ bản là một tiến trình con (sub-process). Một đơn vị xử lý nhỏ nhất của máy tính có thể thực hiện một công việc riêng biệt. Trong Java, các luồng được quản lý bởi máy ảo Java (JVM).</p>
<h3 id="multi-thread-la-gi" class="ftwp-heading"><span id="Thread_la_gi_Multi-thread_la_gi">Multi-thread là gì?</span></h3>
<p><strong>Multi-thread</strong> (đa luồng) là một tiến trình thực hiện nhiều luồng đồng thời. Một ứng dụng Java ngoài luồng chính có thể có các luồng khác thực thi đồng thời làm ứng dụng chạy nhanh và hiệu quả hơn.</p>
<p>VD: Trình duyệt web hay các chương trình chơi nhạc là 1 ví dụ điển hình về đa luồng.</p>
<p>+ Khi duyệt 1 trang web, có rất nhiều hình ảnh, CSS, javascript… được tải đồng thời bởi các luồng khác nhau.</p>
<p>+ Khi play nhạc, chúng ta vẫn có thể tương tác được với nút điều khiển như: Play, pause, next, back … vì luồng phát nhạc là luồng riêng biệt với luồng tiếp nhận tương tác của người dùng.</p>
<p><strong><a href="https://topdev.vn/viec-lam-it/java-kt21">Tuyển dụng Java</a> lương cao up to 2000USD</strong></p>
<h3 id="da-nhiem-multitasking" class="ftwp-heading"><span id="Da_nhiem_multitasking">Đa nhiệm (multitasking)</span></h3>
<p><strong>Multitasking</strong>: Là khả năng chạy đồng thời một hoặc nhiều chương trình cùng một lúc trên một hệ điều hành. Hệ điều hành quản lý việc này và sắp xếp lịch phù hợp cho các chương trình đó. Ví dụ, trên hệ điều hành Windows chúng ta có làm việc đồng thời với các chương trình khác nhau như: Microsoft Word, Excel, Media Player, …</p>
<p>Chúng ta sử dụng đa nhiệm để tận dụng tính năng của CPU.</p>
<p>Đa nhiệm có thể đạt được bằng hai cách:</p>
<ol>
<li>Đa nhiệm dựa trên đơn tiến trình (Process) – Đa tiến trình (Multiprocessing).
<ul>
<li>Mỗi tiến trình có địa chỉ riêng trong bộ nhớ, tức là mỗi tiến trình phân bổ vùng nhớ riêng biệt.</li>
<li>Tiến trình là nặng.</li>
<li>Sự giao tiếp giữa các tiến trình có chi phí cao.</li>
<li>Chuyển đổi từ tiến trình này sang tiến trình khác đòi hỏi thời gian để đăng ký việc lưu và tải các bản đồ bộ nhớ, các danh sách cập nhật, …</li>
</ul>
</li>
<li>Đa nhiệm dựa trên luồng (Thread) – Đa luồng (MultiThreading).
<ul>
<li>Các luồng chia sẻ không gian địa chỉ ô nhớ giống nhau.</li>
<li>Luồng là nhẹ.</li>
<li>Sự giao tiếp giữa các luồng có chi phí thấp.</li>
</ul>
</li>
</ol>
<p>Đa tiến trình (multiprocessing) và đa luồng (multithreading) cả hai được sử dụng để tạo ra hệ thống đa nhiệm (multitasking). Nhưng chúng ta sử dụng đa luồng nhiều hơn đa tiến trình bởi vì các luồng chia sẻ một vùng bộ nhớ chung. Chúng không phân bổ vùng bộ nhớ riêng biệt để tiết kiệm bộ nhớ, và chuyển đổi ngữ cảnh giữa các luồng mất ít thời gian hơn tiến trình.</p>
<div><a href="https://topdev.vn/blog/lap-trinh-web-voi-java/" target="_blank" rel="dofollow noopener" class="u10448e566f10da7fe7e816a8ec68e068">
<div>  <span class="postTitle">10 Java Web Framework tốt nhất</span></div>
</a></div>
<div><a href="https://topdev.vn/blog/hoc-lap-trinh-java/" target="_blank" rel="dofollow noopener" class="ua660a34c2fa53301e1129664f0600d51">
<div>  <span class="postTitle">10 lý do cho thấy tại sao bạn nên theo học ngôn ngữ lập trình Java</span></div>
</a></div>
<h2 id="uu-diem-cua-multi-thread-java" class="ftwp-heading"><span id="Uu_diem_cua_da_luong">Ưu điểm của Multi-thread Java</span></h2>
<p>Đầu tiên, đa luồng giúp <strong>tăng hiệu suất</strong> của ứng dụng bằng cách chạy song song nhiều tác vụ. Thay vì thực hiện tuần tự, các tác vụ có thể xử lý đồng thời, tận dụng tối đa CPU, đặc biệt trong môi trường đa lõi (multi-core). Mỗi luồng có thể dùng chung và chia sẻ nguồn tài nguyên trong quá trình chạy, nhưng có thể thực hiện một cách độc lập.</p>
<p>Đa luồng còn giúp <strong>cải thiện tính đáp ứng</strong> của ứng dụng. Trong các ứng dụng giao diện người dùng (UI), việc sử dụng đa luồng tránh tình trạng ứng dụng bị “treo” khi thực hiện các tác vụ dài, từ đó cải thiện trải nghiệm người dùng. Điều này rất quan trọng khi cần thực hiện các tác vụ nặng như tải dữ liệu hoặc xử lý I/O.</p>
<p>Ngoài ra, đa luồng hỗ trợ <strong>xử lý đồng thời nhiều yêu cầu</strong>. Đối với các hệ thống máy chủ hoặc ứng dụng web, đa luồng cho phép xử lý nhiều yêu cầu của người dùng cùng lúc, giảm thời gian chờ đợi và tăng khả năng phục vụ. Các luồng cũng chia sẻ tài nguyên bộ nhớ, giúp tiết kiệm tài nguyên so với việc tạo nhiều tiến trình riêng biệt.</p>
<h2 id="nhuoc-diem-cua-da-luong-trong-java" class="ftwp-heading"><span id="Nhuoc_diem_cua_da_luong">Nhược điểm của đa luồng trong Java</span></h2>
<p>Tuy nhiên, lập trình đa luồng có một số nhược điểm lớn. <strong>Độ phức tạp</strong> của nó là một trong những thách thức lớn nhất. Khi làm việc với nhiều luồng, lập trình viên phải xử lý đồng bộ hóa, phối hợp luồng và tránh các lỗi như deadlock (tình trạng chết) hoặc race condition (điều kiện cạnh tranh). Điều này đòi hỏi kỹ năng cao và kinh nghiệm.</p>
<p><strong>Đồng bộ hóa dữ liệu</strong> giữa các luồng cũng là một vấn đề quan trọng. Khi nhiều luồng truy cập chung một tài nguyên, nếu không đồng bộ đúng cách, dữ liệu có thể bị thay đổi ngoài ý muốn, dẫn đến lỗi. Đồng bộ hóa giúp ngăn chặn tình trạng này, nhưng nó làm giảm hiệu suất vì các luồng phải chờ nhau. Đồng thời, nếu đồng bộ không chính xác, có thể gây ra tình trạng <strong>deadlock</strong>, khi các luồng bị khóa lẫn nhau và không thể tiếp tục thực thi.</p>
<div class="bbCodeBlock bbCodeBlock--expandable bbCodeBlock--quote is-expandable">
<div class="bbCodeBlock-content">
<div class="bbCodeBlock-expandContent">
<blockquote>
<p>Deadlock (Khoá chết) là gì? Deadlock xảy ra khi 2 tiến trình đợi nhau hoàn thành, trước khi chạy. Kết quả của quá trình là cả 2 tiến trình không bao giờ kết thúc</p>
</blockquote>
</div>
<div class="bbCodeBlock-expandLink"><a class="expand">Xem tiếp...</a></div>
</div>
</div>
<p>Một vấn đề khác là <strong>race condition</strong>, khi nhiều luồng cùng thao tác với một tài nguyên mà không kiểm soát đúng cách. Điều này có thể dẫn đến dữ liệu không chính xác hoặc bị hỏng.</p>
<p>Cuối cùng, lập trình đa luồng còn dẫn đến <strong>tăng sử dụng tài nguyên</strong>. Mỗi luồng yêu cầu bộ nhớ và CPU riêng, và khi có quá nhiều luồng, việc chuyển đổi giữa các luồng (context switching) làm giảm hiệu suất tổng thể của hệ thống.</p>
<h2 id="vong-doi-cac-trang-thai-cua-mot-thread-trong-java" class="ftwp-heading"><span id="Vong_doi_cac_trang_thai_cua_mot_Thread_trong_java">Vòng đời (các trạng thái) của một Thread trong Java</span></h2>
<figure class="alignnone size-full wp-image-30795 ls-is-cached lazyloaded"><img  src="https://topdev.vn/blog/wp-content/uploads/2020/10/multithread-lifecylce.jpg" sizes="(max-width: 525px) 100vw, 525px" srcset="https://topdev.vn/blog/wp-content/uploads/2020/10/multithread-lifecylce.jpg 525w, https://topdev.vn/blog/wp-content/uploads/2020/10/multithread-lifecylce-300x199.jpg 300w" alt="Lập trình đa luồng trong Java (Java Multi-threading)" width="525" height="349" loading="lazy" data-srcset="https://topdev.vn/blog/wp-content/uploads/2020/10/multithread-lifecylce.jpg 525w, https://topdev.vn/blog/wp-content/uploads/2020/10/multithread-lifecylce-300x199.jpg 300w" data-src="https://topdev.vn/blog/wp-content/uploads/2020/10/multithread-lifecylce.jpg" data-sizes="(max-width: 525px) 100vw, 525px" data-is-external-image="true"></figure>
<p>Vòng đời của thread trong java được kiểm soát bởi JVM. Java định nghĩa các trạng thái của luồng trong các thuộc tính static của lớp <strong>Thread.State</strong>:</p>
<ul>
<li><strong>NEW </strong>: Đây là trạng thái khi luồng vừa được khởi tạo bằng phương thức khởi tạo của lớp Thread nhưng chưa được start(). Ở trạng thái này, luồng được tạo ra nhưng chưa được cấp phát tài nguyên và cũng chưa chạy. Nếu luồng đang ở trạng thái này mà ta gọi các phương thức ép buộc stop,resume,suspend … sẽ là nguyên nhân sảy ra ngoại lệ IllegalThreadStateException .</li>
<li><strong>RUNNABLE </strong>: Sau khi gọi phương thức start() thì luồng test đã được cấp phát tài nguyên và các lịch điều phối CPU cho luồng test cũng bắt đầu có hiệu lực. Ở đây, chúng ta dùng trạng thái là Runnable chứ không phải Running, vì luồng không thực sự luôn chạy mà tùy vào hệ thống mà có sự điều phối CPU khác nhau.</li>
<li><strong>WAITING</strong> : Thread chờ không giới hạn cho đến khi một luồng khác đánh thức nó.</li>
<li><strong>TIMED_WAITING</strong> : Thread chờ trong một thời gian nhất định, hoặc là có một luồng khác đánh thức nó.</li>
<li><strong>BLOCKED</strong>: Đây là 1 dạng của trạng thái “Not Runnable”, là trạng thái khi Thread vẫn còn sống, nhưng hiện tại không được chọn để chạy. Thread chờ một monitor để unlock một đối tượng mà nó cần.</li>
<li><strong>TERMINATED </strong>: Một thread ở trong trạng thái terminated hoặc dead khi phương thức run() của nó bị thoát.</li>
</ul>
<h2 id="cach-tao-thread-trong-java" class="ftwp-heading"><span id="Cach_tao_luong_trong_Java">Cách tạo thread trong Java</span></h2>
<p>Trong java ta có thể tạo ra một luồng bằng một trong hai cách sau: tạo 1 đối tượng của lớp được <strong>extend</strong> từ <strong>class Thread</strong> hoặc <strong>implements</strong> từ <strong>interface Runnable</strong>.</p>
<h3 id="tao-luong-bang-cach-extend-tu-lop-thread" class="ftwp-heading"><span id="Tao_luong_bang_cach_extend_tu_lop_Thread">Tạo luồng bằng cách extend từ lớp Thread</span></h3>
<p>Để tạo luồng bằng cách tạo lớp kế thừa từ lớp Thread, ta phải làm các công việc sau :</p>
<ol>
<li>Khai báo 1 lớp mới kế thừa từ lớp Thread</li>
<li>Override lại phương thức run ở lớp này, những gì trong phương thức run sẽ được thực thi khi luồng bắt đầu chạy. Sau khi luồng chạy xong tất cả các câu lệnh trong phương thức run thì luồng cũng tự hủy.</li>
<li>Tạo 1 thể hiện (hay 1 đối tượng) của lớp ta vừa khai báo.</li>
<li>Sau đó gọi phương thức start() của đối tượng này để bắt đầu thực thi luồng.</li>
</ol>
<div class="code-content">
<div class="code-expandContent">
<pre class=" prettyprinted"><span class="kwd">package</span><span class="pln"> com</span><span class="pun">.</span><span class="pln">gpcoder</span><span class="pun">.</span><span class="pln">simple</span><span class="pun">;</span>

<span class="kwd">public</span> <span class="kwd">class</span> <span class="typ">TheadSimple</span> <span class="kwd">extends</span> <span class="typ">Thread</span> <span class="pun">{</span><span class="pln">
    </span><span class="kwd">public</span> <span class="kwd">void</span><span class="pln"> run</span><span class="pun">()</span> <span class="pun">{</span><span class="pln">
        </span><span class="typ">System</span><span class="pun">.</span><span class="kwd">out</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="str">"thread is running..."</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="kwd">public</span> <span class="kwd">static</span> <span class="kwd">void</span><span class="pln"> main</span><span class="pun">(</span><span class="typ">String</span><span class="pln"> args</span><span class="pun">[])</span> <span class="pun">{</span><span class="pln">
        </span><span class="typ">TheadSimple</span><span class="pln"> t1 </span><span class="pun">=</span> <span class="kwd">new</span> <span class="typ">TheadSimple</span><span class="pun">();</span><span class="pln">
        t1</span><span class="pun">.</span><span class="pln">start</span><span class="pun">();</span><span class="pln">
    </span><span class="pun">}</span>
<span class="pun">}</span></pre>
</div>
<div class="bbCodeBlock-expandLink"><a class="expand">Xem tiếp...</a></div>
</div>
<p><strong>Lưu ý :</strong></p>
<ul>
<li>Tuy ta khai báo những công việc cần làm của luồng trong phương thức run() nhưng khi thực thi luồng ta phải gọi phương thức start(). Vì đây là phương thức đặc biệt mà java xây dựng sẵn trong lớp Thread, phương thức này sẽ cấp phát tài nguyên cho luồng mới rồi chạy phương thức run() ở luồng này. Vì vậy, nếu ta gọi phương thức run() mà không gọi start() thì cũng tương đương với việc gọi 1 phương thức của 1 đối tượng bình thường và phương thức vẫn chạy trên luồng mà gọi phương thức chứ không chạy ở luồng mới tạo ra, nên vẫn chỉ có 1 luồng chính làm việc chứ ứng dụng vẫn không phải là đa luồng.</li>
<li>Sau khi start một thread, nó không bao giờ có thể được start lại. Nếu bạn làm như vậy, một ngoại lệ <strong>IllegalThreadStateException</strong> sẽ xảy ra.</li>
</ul>
<h3 id="tao-luong-bang-cach-implement-tu-interface-runnable" class="ftwp-heading"><span id="Tao_luong_bang_cach_implement_tu_Interface_Runnable">Tạo luồng bằng cách implement từ Interface Runnable</span></h3>
<p>Để tạo luồng bằng cách hiện thực từ Interface Runnable, ta phải làm các công việc sau :</p>
<ol>
<li>Khai báo 1 lớp mới implements từ Interface Runnable</li>
<li>Hiện thực phương thức run() ở lớp này, những gì trong phương thức run() sẽ được thực thi khi luồng bắt đầu chạy. Sau khi luồng chạy xong tất cả các câu lệnh trong phương thức run thì luồng cũng tự hủy.</li>
<li>Tạo 1 thể hiện (hay 1 đối tượng) của lớp ta vừa khai báo. (VD : Tên đối tượng là r1)</li>
<li>Tạo 1 thể hiện của lớp Thread bằng phương thức khởi tạo : Thread(Runnable target)
<ul>
<li>Runnable target: Là 1 đối tượng thuốc lớp được implements từ giao diện Runnable.</li>
<li>Ví dụ: Thread t1 = new Thread(r1);</li>
</ul>
</li>
<li>Gọi phương thức start() của đối tượng t1.</li>
</ol>
<div class="code-content">
<div class="code-expandContent">
<pre class=" prettyprinted"><span class="kwd">package</span><span class="pln"> com</span><span class="pun">.</span><span class="pln">gpcoder</span><span class="pun">.</span><span class="pln">simple</span><span class="pun">;</span>

<span class="kwd">public</span> <span class="kwd">class</span> <span class="typ">RunnableSimple</span> <span class="kwd">implements</span> <span class="typ">Runnable</span> <span class="pun">{</span><span class="pln">
    </span><span class="kwd">public</span> <span class="kwd">void</span><span class="pln"> run</span><span class="pun">()</span> <span class="pun">{</span><span class="pln">
        </span><span class="typ">System</span><span class="pun">.</span><span class="kwd">out</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="str">"thread is running..."</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="kwd">public</span> <span class="kwd">static</span> <span class="kwd">void</span><span class="pln"> main</span><span class="pun">(</span><span class="typ">String</span><span class="pln"> args</span><span class="pun">[])</span> <span class="pun">{</span><span class="pln">
        </span><span class="typ">RunnableSimple</span><span class="pln"> runable </span><span class="pun">=</span> <span class="kwd">new</span> <span class="typ">RunnableSimple</span><span class="pun">();</span><span class="pln">
        </span><span class="typ">Thread</span><span class="pln"> t1 </span><span class="pun">=</span> <span class="kwd">new</span> <span class="typ">Thread</span><span class="pun">(</span><span class="pln">runable</span><span class="pun">);</span><span class="pln">
        t1</span><span class="pun">.</span><span class="pln">start</span><span class="pun">();</span><span class="pln">
    </span><span class="pun">}</span>
<span class="pun">}</span></pre>
</div>
<div class="bbCodeBlock-expandLink"><a class="expand">Xem tiếp...</a></div>
</div>
<h3 id="khi-nao-implements-tu-interface-runnable" class="ftwp-heading"><span id="Khi_nao_implements_tu_interface_Runnable">Khi nào implements từ interface Runnable?</span></h3>
<p>+ Cách hay được sử dụng và được yêu thích là dùng <strong>interface Runnable</strong>, bởi vì nó không yêu cầu phải tạo một lớp kế thừa từ lớp Thread. Trong trường hợp ứng dụng thiết kế yêu cầu sử dụng đa kế thừa, chỉ có interface mới có thể giúp giải quyết vấn đề. Ngoài ra, <strong>Thread Pool</strong> rất hiểu quả và có thể được cài đặt, sử dụng rất hơn giản.<br>+ Trong trường hợp còn lại ta có thể kế thừa từ lớp Thread.</p>
<h2 id="vi-du-minh-hoa-su-dung-da-luong" class="ftwp-heading"><span id="Vi_du_minh_hoa_su_dung_da_luong">Ví dụ minh họa sử dụng đa luồng</span></h2>
<h3 id="vi-du-tao-luong-bang-cach-extend-tu-class-thread" class="ftwp-heading"><span id="Vi_du_Tao_luong_bang_cach_extend_tu_class_Thread">Ví dụ Tạo luồng bằng cách extend từ class Thread</span></h3>
<p>Tạo luồng extend từ class Thead</p>
<div class="code-content">
<div class="code-expandContent">
<pre class=" prettyprinted"><span class="kwd">package</span><span class="pln"> com</span><span class="pun">.</span><span class="pln">gpcoder</span><span class="pun">.</span><span class="pln">flow</span><span class="pun">;</span>

<span class="kwd">public</span> <span class="kwd">class</span> <span class="typ">ThreadDemo</span> <span class="kwd">extends</span> <span class="typ">Thread</span> <span class="pun">{</span><span class="pln">
    </span><span class="kwd">private</span> <span class="typ">Thread</span><span class="pln"> t</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">private</span> <span class="typ">String</span><span class="pln"> threadName</span><span class="pun">;</span><span class="pln">

    </span><span class="typ">ThreadDemo</span><span class="pun">(</span><span class="typ">String</span><span class="pln"> name</span><span class="pun">)</span> <span class="pun">{</span><span class="pln">
        threadName </span><span class="pun">=</span><span class="pln"> name</span><span class="pun">;</span><span class="pln">
        </span><span class="typ">System</span><span class="pun">.</span><span class="kwd">out</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="str">"Creating "</span> <span class="pun">+</span><span class="pln"> threadName</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="lit">@Override</span><span class="pln">
    </span><span class="kwd">public</span> <span class="kwd">void</span><span class="pln"> run</span><span class="pun">()</span> <span class="pun">{</span><span class="pln">
        </span><span class="typ">System</span><span class="pun">.</span><span class="kwd">out</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="str">"Running "</span> <span class="pun">+</span><span class="pln"> threadName</span><span class="pun">);</span><span class="pln">
        </span><span class="kwd">try</span> <span class="pun">{</span><span class="pln">
            </span><span class="kwd">for</span> <span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span> <span class="lit">4</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&gt;</span> <span class="lit">0</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">--)</span> <span class="pun">{</span><span class="pln">
                </span><span class="typ">System</span><span class="pun">.</span><span class="kwd">out</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="str">"Thread: "</span> <span class="pun">+</span><span class="pln"> threadName </span><span class="pun">+</span> <span class="str">", "</span> <span class="pun">+</span><span class="pln"> i</span><span class="pun">);</span><span class="pln">
                </span><span class="com">// Let the thread sleep for a while.</span><span class="pln">
                </span><span class="typ">Thread</span><span class="pun">.</span><span class="pln">sleep</span><span class="pun">(</span><span class="lit">50</span><span class="pun">);</span><span class="pln">
            </span><span class="pun">}</span><span class="pln">
        </span><span class="pun">}</span> <span class="kwd">catch</span> <span class="pun">(</span><span class="typ">InterruptedException</span><span class="pln"> e</span><span class="pun">)</span> <span class="pun">{</span><span class="pln">
            </span><span class="typ">System</span><span class="pun">.</span><span class="kwd">out</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="str">"Thread "</span> <span class="pun">+</span><span class="pln"> threadName </span><span class="pun">+</span> <span class="str">" interrupted."</span><span class="pun">);</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
        </span><span class="typ">System</span><span class="pun">.</span><span class="kwd">out</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="str">"Thread "</span> <span class="pun">+</span><span class="pln"> threadName </span><span class="pun">+</span> <span class="str">" exiting."</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="kwd">public</span> <span class="kwd">void</span><span class="pln"> start</span><span class="pun">()</span> <span class="pun">{</span><span class="pln">
        </span><span class="typ">System</span><span class="pun">.</span><span class="kwd">out</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="str">"Starting "</span> <span class="pun">+</span><span class="pln"> threadName</span><span class="pun">);</span><span class="pln">
        </span><span class="kwd">if</span> <span class="pun">(</span><span class="pln">t </span><span class="pun">==</span> <span class="kwd">null</span><span class="pun">)</span> <span class="pun">{</span><span class="pln">
            t </span><span class="pun">=</span> <span class="kwd">new</span> <span class="typ">Thread</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">,</span><span class="pln"> threadName</span><span class="pun">);</span><span class="pln">
            t</span><span class="pun">.</span><span class="pln">start</span><span class="pun">();</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
    </span><span class="pun">}</span>

<span class="pun">}</span></pre>
</div>
<div class="bbCodeBlock-expandLink"><a class="expand">Xem tiếp...</a></div>
</div>
<p>Chương trình sử dụng đa luồng:</p>
<div class="code-content">
<div class="code-expandContent">
<pre class=" prettyprinted"><span class="kwd">package</span><span class="pln"> com</span><span class="pun">.</span><span class="pln">gpcoder</span><span class="pun">.</span><span class="pln">flow</span><span class="pun">;</span>

<span class="kwd">public</span> <span class="kwd">class</span> <span class="typ">ThreadDemoTest</span> <span class="pun">{</span><span class="pln">
    </span><span class="kwd">public</span> <span class="kwd">static</span> <span class="kwd">void</span><span class="pln"> main</span><span class="pun">(</span><span class="typ">String</span><span class="pln"> args</span><span class="pun">[])</span> <span class="pun">{</span><span class="pln">
        </span><span class="typ">System</span><span class="pun">.</span><span class="kwd">out</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="str">"Main thread running... "</span><span class="pun">);</span><span class="pln">

        </span><span class="typ">ThreadDemo</span><span class="pln"> T1 </span><span class="pun">=</span> <span class="kwd">new</span> <span class="typ">ThreadDemo</span><span class="pun">(</span><span class="str">"Thread-1-HR-Database"</span><span class="pun">);</span><span class="pln">
        T1</span><span class="pun">.</span><span class="pln">start</span><span class="pun">();</span><span class="pln">

        </span><span class="typ">ThreadDemo</span><span class="pln"> T2 </span><span class="pun">=</span> <span class="kwd">new</span> <span class="typ">ThreadDemo</span><span class="pun">(</span><span class="str">"Thread-2-Send-Email"</span><span class="pun">);</span><span class="pln">
        T2</span><span class="pun">.</span><span class="pln">start</span><span class="pun">();</span><span class="pln">

        </span><span class="typ">System</span><span class="pun">.</span><span class="kwd">out</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="str">"==&gt; Main thread stopped!!! "</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span>
<span class="pun">}</span></pre>
</div>
<div class="bbCodeBlock-expandLink"><a class="expand">Xem tiếp...</a></div>
</div>
<p>Kết quả thực thi chương trình trên:</p>
<div class="code-content">
<div class="code-expandContent">
<pre class=" prettyprinted"><span class="typ">Main</span><span class="pln"> thread running</span><span class="pun">...</span>
<span class="typ">Creating</span> <span class="typ">Thread</span><span class="pun">-</span><span class="lit">1</span><span class="pun">-</span><span class="pln">HR</span><span class="pun">-</span><span class="typ">Database</span>
<span class="typ">Starting</span> <span class="typ">Thread</span><span class="pun">-</span><span class="lit">1</span><span class="pun">-</span><span class="pln">HR</span><span class="pun">-</span><span class="typ">Database</span>
<span class="typ">Creating</span> <span class="typ">Thread</span><span class="pun">-</span><span class="lit">2</span><span class="pun">-</span><span class="typ">Send</span><span class="pun">-</span><span class="typ">Email</span>
<span class="typ">Starting</span> <span class="typ">Thread</span><span class="pun">-</span><span class="lit">2</span><span class="pun">-</span><span class="typ">Send</span><span class="pun">-</span><span class="typ">Email</span>
<span class="pun">==&gt;</span> <span class="typ">Main</span><span class="pln"> thread stopped</span><span class="pun">!!!</span>
<span class="typ">Running</span> <span class="typ">Thread</span><span class="pun">-</span><span class="lit">1</span><span class="pun">-</span><span class="pln">HR</span><span class="pun">-</span><span class="typ">Database</span>
<span class="typ">Running</span> <span class="typ">Thread</span><span class="pun">-</span><span class="lit">2</span><span class="pun">-</span><span class="typ">Send</span><span class="pun">-</span><span class="typ">Email</span>
<span class="typ">Thread</span><span class="pun">:</span> <span class="typ">Thread</span><span class="pun">-</span><span class="lit">2</span><span class="pun">-</span><span class="typ">Send</span><span class="pun">-</span><span class="typ">Email</span><span class="pun">,</span> <span class="lit">4</span>
<span class="typ">Thread</span><span class="pun">:</span> <span class="typ">Thread</span><span class="pun">-</span><span class="lit">1</span><span class="pun">-</span><span class="pln">HR</span><span class="pun">-</span><span class="typ">Database</span><span class="pun">,</span> <span class="lit">4</span>
<span class="typ">Thread</span><span class="pun">:</span> <span class="typ">Thread</span><span class="pun">-</span><span class="lit">1</span><span class="pun">-</span><span class="pln">HR</span><span class="pun">-</span><span class="typ">Database</span><span class="pun">,</span> <span class="lit">3</span>
<span class="typ">Thread</span><span class="pun">:</span> <span class="typ">Thread</span><span class="pun">-</span><span class="lit">2</span><span class="pun">-</span><span class="typ">Send</span><span class="pun">-</span><span class="typ">Email</span><span class="pun">,</span> <span class="lit">3</span>
<span class="typ">Thread</span><span class="pun">:</span> <span class="typ">Thread</span><span class="pun">-</span><span class="lit">2</span><span class="pun">-</span><span class="typ">Send</span><span class="pun">-</span><span class="typ">Email</span><span class="pun">,</span> <span class="lit">2</span>
<span class="typ">Thread</span><span class="pun">:</span> <span class="typ">Thread</span><span class="pun">-</span><span class="lit">1</span><span class="pun">-</span><span class="pln">HR</span><span class="pun">-</span><span class="typ">Database</span><span class="pun">,</span> <span class="lit">2</span>
<span class="typ">Thread</span><span class="pun">:</span> <span class="typ">Thread</span><span class="pun">-</span><span class="lit">2</span><span class="pun">-</span><span class="typ">Send</span><span class="pun">-</span><span class="typ">Email</span><span class="pun">,</span> <span class="lit">1</span>
<span class="typ">Thread</span><span class="pun">:</span> <span class="typ">Thread</span><span class="pun">-</span><span class="lit">1</span><span class="pun">-</span><span class="pln">HR</span><span class="pun">-</span><span class="typ">Database</span><span class="pun">,</span> <span class="lit">1</span>
<span class="typ">Thread</span> <span class="typ">Thread</span><span class="pun">-</span><span class="lit">2</span><span class="pun">-</span><span class="typ">Send</span><span class="pun">-</span><span class="typ">Email</span><span class="pln"> exiting</span><span class="pun">.</span>
<span class="typ">Thread</span> <span class="typ">Thread</span><span class="pun">-</span><span class="lit">1</span><span class="pun">-</span><span class="pln">HR</span><span class="pun">-</span><span class="typ">Database</span><span class="pln"> exiting</span><span class="pun">.</span></pre>
</div>
<div class="bbCodeBlock-expandLink"><a class="expand">Xem tiếp...</a></div>
</div>
<p>Kết quả chương trình trên được giải thích thông qua hình bên dưới:</p>
<figure class="alignnone size-full wp-image-30796 ls-is-cached lazyloaded"><img  src="https://topdev.vn/blog/wp-content/uploads/2020/10/Multi-Thread-Flow.png" sizes="(max-width: 952px) 100vw, 952px" srcset="https://topdev.vn/blog/wp-content/uploads/2020/10/Multi-Thread-Flow.png 952w, https://topdev.vn/blog/wp-content/uploads/2020/10/Multi-Thread-Flow-300x168.png 300w, https://topdev.vn/blog/wp-content/uploads/2020/10/Multi-Thread-Flow-768x429.png 768w, https://topdev.vn/blog/wp-content/uploads/2020/10/Multi-Thread-Flow-696x389.png 696w, https://topdev.vn/blog/wp-content/uploads/2020/10/Multi-Thread-Flow-752x420.png 752w" alt="Lập trình đa luồng trong Java (Java Multi-threading)" width="952" height="532" loading="lazy" data-srcset="https://topdev.vn/blog/wp-content/uploads/2020/10/Multi-Thread-Flow.png 952w, https://topdev.vn/blog/wp-content/uploads/2020/10/Multi-Thread-Flow-300x168.png 300w, https://topdev.vn/blog/wp-content/uploads/2020/10/Multi-Thread-Flow-768x429.png 768w, https://topdev.vn/blog/wp-content/uploads/2020/10/Multi-Thread-Flow-696x389.png 696w, https://topdev.vn/blog/wp-content/uploads/2020/10/Multi-Thread-Flow-752x420.png 752w" data-src="https://topdev.vn/blog/wp-content/uploads/2020/10/Multi-Thread-Flow.png" data-sizes="(max-width: 952px) 100vw, 952px" data-is-external-image="true"></figure>
<h3 id="vi-du-tao-luong-bang-cach-implement-tu-interface-runnable" class="ftwp-heading"><span id="Vi_duTao_luong_bang_cach_implement_tu_Interface_Runnable">Ví dụ Tạo luồng bằng cách implement từ Interface Runnable</span></h3>
<p>Tạo luồng implement từ Interface Runnable</p>
<div class="code-content">
<div class="code-expandContent">
<pre class=" prettyprinted"><span class="kwd">package</span><span class="pln"> com</span><span class="pun">.</span><span class="pln">gpcoder</span><span class="pun">.</span><span class="pln">flow</span><span class="pun">;</span>

<span class="kwd">class</span> <span class="typ">RunnableDemo</span> <span class="kwd">implements</span> <span class="typ">Runnable</span> <span class="pun">{</span><span class="pln">
    </span><span class="kwd">private</span> <span class="typ">Thread</span><span class="pln"> t</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">private</span> <span class="typ">String</span><span class="pln"> threadName</span><span class="pun">;</span><span class="pln">

    </span><span class="typ">RunnableDemo</span><span class="pun">(</span><span class="typ">String</span><span class="pln"> name</span><span class="pun">)</span> <span class="pun">{</span><span class="pln">
        threadName </span><span class="pun">=</span><span class="pln"> name</span><span class="pun">;</span><span class="pln">
        </span><span class="typ">System</span><span class="pun">.</span><span class="kwd">out</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="str">"Creating "</span> <span class="pun">+</span><span class="pln"> threadName</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="lit">@Override</span><span class="pln">
    </span><span class="kwd">public</span> <span class="kwd">void</span><span class="pln"> run</span><span class="pun">()</span> <span class="pun">{</span><span class="pln">
        </span><span class="typ">System</span><span class="pun">.</span><span class="kwd">out</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="str">"Running "</span> <span class="pun">+</span><span class="pln"> threadName</span><span class="pun">);</span><span class="pln">
        </span><span class="kwd">try</span> <span class="pun">{</span><span class="pln">
            </span><span class="kwd">for</span> <span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span> <span class="lit">4</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&gt;</span> <span class="lit">0</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">--)</span> <span class="pun">{</span><span class="pln">
                </span><span class="typ">System</span><span class="pun">.</span><span class="kwd">out</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="str">"Thread: "</span> <span class="pun">+</span><span class="pln"> threadName </span><span class="pun">+</span> <span class="str">", "</span> <span class="pun">+</span><span class="pln"> i</span><span class="pun">);</span><span class="pln">
                </span><span class="com">// Let the thread sleep for a while.</span><span class="pln">
                </span><span class="typ">Thread</span><span class="pun">.</span><span class="pln">sleep</span><span class="pun">(</span><span class="lit">50</span><span class="pun">);</span><span class="pln">
            </span><span class="pun">}</span><span class="pln">
        </span><span class="pun">}</span> <span class="kwd">catch</span> <span class="pun">(</span><span class="typ">InterruptedException</span><span class="pln"> e</span><span class="pun">)</span> <span class="pun">{</span><span class="pln">
            </span><span class="typ">System</span><span class="pun">.</span><span class="kwd">out</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="str">"Thread "</span> <span class="pun">+</span><span class="pln"> threadName </span><span class="pun">+</span> <span class="str">" interrupted."</span><span class="pun">);</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
        </span><span class="typ">System</span><span class="pun">.</span><span class="kwd">out</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="str">"Thread "</span> <span class="pun">+</span><span class="pln"> threadName </span><span class="pun">+</span> <span class="str">" exiting."</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="kwd">public</span> <span class="kwd">void</span><span class="pln"> start</span><span class="pun">()</span> <span class="pun">{</span><span class="pln">
        </span><span class="typ">System</span><span class="pun">.</span><span class="kwd">out</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="str">"Starting "</span> <span class="pun">+</span><span class="pln"> threadName</span><span class="pun">);</span><span class="pln">
        </span><span class="kwd">if</span> <span class="pun">(</span><span class="pln">t </span><span class="pun">==</span> <span class="kwd">null</span><span class="pun">)</span> <span class="pun">{</span><span class="pln">
            t </span><span class="pun">=</span> <span class="kwd">new</span> <span class="typ">Thread</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">,</span><span class="pln"> threadName</span><span class="pun">);</span><span class="pln">
            t</span><span class="pun">.</span><span class="pln">start</span><span class="pun">();</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
    </span><span class="pun">}</span>

<span class="pun">}</span></pre>
</div>
<div class="bbCodeBlock-expandLink"><a class="expand">Xem tiếp...</a></div>
</div>
<p>Chương trình sử dụng đa luồng:</p>
<div class="code-content">
<div class="code-expandContent">
<pre class=" prettyprinted"><span class="kwd">package</span><span class="pln"> com</span><span class="pun">.</span><span class="pln">gpcoder</span><span class="pun">.</span><span class="pln">flow</span><span class="pun">;</span>

<span class="kwd">public</span> <span class="kwd">class</span> <span class="typ">RunnableDemoTest</span> <span class="pun">{</span><span class="pln">
    </span><span class="kwd">public</span> <span class="kwd">static</span> <span class="kwd">void</span><span class="pln"> main</span><span class="pun">(</span><span class="typ">String</span><span class="pln"> args</span><span class="pun">[])</span> <span class="pun">{</span><span class="pln">
        </span><span class="typ">System</span><span class="pun">.</span><span class="kwd">out</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="str">"Main thread running... "</span><span class="pun">);</span><span class="pln">

        </span><span class="typ">RunnableDemo</span><span class="pln"> R1 </span><span class="pun">=</span> <span class="kwd">new</span> <span class="typ">RunnableDemo</span><span class="pun">(</span><span class="str">"Thread-1-HR-Database"</span><span class="pun">);</span><span class="pln">
        R1</span><span class="pun">.</span><span class="pln">start</span><span class="pun">();</span><span class="pln">

        </span><span class="typ">RunnableDemo</span><span class="pln"> R2 </span><span class="pun">=</span> <span class="kwd">new</span> <span class="typ">RunnableDemo</span><span class="pun">(</span><span class="str">"Thread-2-Send-Email"</span><span class="pun">);</span><span class="pln">
        R2</span><span class="pun">.</span><span class="pln">start</span><span class="pun">();</span><span class="pln">

        </span><span class="typ">System</span><span class="pun">.</span><span class="kwd">out</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="str">"==&gt; Main thread stopped!!! "</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span>
<span class="pun">}</span></pre>
</div>
<div class="bbCodeBlock-expandLink"><a class="expand">Xem tiếp...</a></div>
</div>
<p>Kết quả thực thi chương trình trên:</p>
<div class="code-content">
<div class="code-expandContent">
<pre class=" prettyprinted"><span class="typ">Main</span><span class="pln"> thread running</span><span class="pun">...</span>
<span class="typ">Creating</span> <span class="typ">Thread</span><span class="pun">-</span><span class="lit">1</span><span class="pun">-</span><span class="pln">HR</span><span class="pun">-</span><span class="typ">Database</span>
<span class="typ">Starting</span> <span class="typ">Thread</span><span class="pun">-</span><span class="lit">1</span><span class="pun">-</span><span class="pln">HR</span><span class="pun">-</span><span class="typ">Database</span>
<span class="typ">Creating</span> <span class="typ">Thread</span><span class="pun">-</span><span class="lit">2</span><span class="pun">-</span><span class="typ">Send</span><span class="pun">-</span><span class="typ">Email</span>
<span class="typ">Starting</span> <span class="typ">Thread</span><span class="pun">-</span><span class="lit">2</span><span class="pun">-</span><span class="typ">Send</span><span class="pun">-</span><span class="typ">Email</span>
<span class="pun">==&gt;</span> <span class="typ">Main</span><span class="pln"> thread stopped</span><span class="pun">!!!</span>
<span class="typ">Running</span> <span class="typ">Thread</span><span class="pun">-</span><span class="lit">1</span><span class="pun">-</span><span class="pln">HR</span><span class="pun">-</span><span class="typ">Database</span>
<span class="typ">Running</span> <span class="typ">Thread</span><span class="pun">-</span><span class="lit">2</span><span class="pun">-</span><span class="typ">Send</span><span class="pun">-</span><span class="typ">Email</span>
<span class="typ">Thread</span><span class="pun">:</span> <span class="typ">Thread</span><span class="pun">-</span><span class="lit">1</span><span class="pun">-</span><span class="pln">HR</span><span class="pun">-</span><span class="typ">Database</span><span class="pun">,</span> <span class="lit">4</span>
<span class="typ">Thread</span><span class="pun">:</span> <span class="typ">Thread</span><span class="pun">-</span><span class="lit">2</span><span class="pun">-</span><span class="typ">Send</span><span class="pun">-</span><span class="typ">Email</span><span class="pun">,</span> <span class="lit">4</span>
<span class="typ">Thread</span><span class="pun">:</span> <span class="typ">Thread</span><span class="pun">-</span><span class="lit">1</span><span class="pun">-</span><span class="pln">HR</span><span class="pun">-</span><span class="typ">Database</span><span class="pun">,</span> <span class="lit">3</span>
<span class="typ">Thread</span><span class="pun">:</span> <span class="typ">Thread</span><span class="pun">-</span><span class="lit">2</span><span class="pun">-</span><span class="typ">Send</span><span class="pun">-</span><span class="typ">Email</span><span class="pun">,</span> <span class="lit">3</span>
<span class="typ">Thread</span><span class="pun">:</span> <span class="typ">Thread</span><span class="pun">-</span><span class="lit">1</span><span class="pun">-</span><span class="pln">HR</span><span class="pun">-</span><span class="typ">Database</span><span class="pun">,</span> <span class="lit">2</span>
<span class="typ">Thread</span><span class="pun">:</span> <span class="typ">Thread</span><span class="pun">-</span><span class="lit">2</span><span class="pun">-</span><span class="typ">Send</span><span class="pun">-</span><span class="typ">Email</span><span class="pun">,</span> <span class="lit">2</span>
<span class="typ">Thread</span><span class="pun">:</span> <span class="typ">Thread</span><span class="pun">-</span><span class="lit">1</span><span class="pun">-</span><span class="pln">HR</span><span class="pun">-</span><span class="typ">Database</span><span class="pun">,</span> <span class="lit">1</span>
<span class="typ">Thread</span><span class="pun">:</span> <span class="typ">Thread</span><span class="pun">-</span><span class="lit">2</span><span class="pun">-</span><span class="typ">Send</span><span class="pun">-</span><span class="typ">Email</span><span class="pun">,</span> <span class="lit">1</span>
<span class="typ">Thread</span> <span class="typ">Thread</span><span class="pun">-</span><span class="lit">1</span><span class="pun">-</span><span class="pln">HR</span><span class="pun">-</span><span class="typ">Database</span><span class="pln"> exiting</span><span class="pun">.</span>
<span class="typ">Thread</span> <span class="typ">Thread</span><span class="pun">-</span><span class="lit">2</span><span class="pun">-</span><span class="typ">Send</span><span class="pun">-</span><span class="typ">Email</span><span class="pln"> exiting</span><span class="pun">.</span></pre>
</div>
<div class="bbCodeBlock-expandLink"><a class="expand">Xem tiếp...</a></div>
</div>
<p>Kết quả chương trình trên được giải thích thông qua hình bên dưới:</p>
<figure class="alignnone size-full wp-image-30797 ls-is-cached lazyloaded"><img  src="https://topdev.vn/blog/wp-content/uploads/2020/10/Multi-Thread-Flow-Runnable.png" sizes="(max-width: 951px) 100vw, 951px" srcset="https://topdev.vn/blog/wp-content/uploads/2020/10/Multi-Thread-Flow-Runnable.png 951w, https://topdev.vn/blog/wp-content/uploads/2020/10/Multi-Thread-Flow-Runnable-300x168.png 300w, https://topdev.vn/blog/wp-content/uploads/2020/10/Multi-Thread-Flow-Runnable-768x430.png 768w, https://topdev.vn/blog/wp-content/uploads/2020/10/Multi-Thread-Flow-Runnable-696x390.png 696w, https://topdev.vn/blog/wp-content/uploads/2020/10/Multi-Thread-Flow-Runnable-749x420.png 749w" alt="Lập trình đa luồng trong Java (Java Multi-threading)" width="951" height="533" loading="lazy" data-srcset="https://topdev.vn/blog/wp-content/uploads/2020/10/Multi-Thread-Flow-Runnable.png 951w, https://topdev.vn/blog/wp-content/uploads/2020/10/Multi-Thread-Flow-Runnable-300x168.png 300w, https://topdev.vn/blog/wp-content/uploads/2020/10/Multi-Thread-Flow-Runnable-768x430.png 768w, https://topdev.vn/blog/wp-content/uploads/2020/10/Multi-Thread-Flow-Runnable-696x390.png 696w, https://topdev.vn/blog/wp-content/uploads/2020/10/Multi-Thread-Flow-Runnable-749x420.png 749w" data-src="https://topdev.vn/blog/wp-content/uploads/2020/10/Multi-Thread-Flow-Runnable.png" data-sizes="(max-width: 951px) 100vw, 951px" data-is-external-image="true"></figure>
<h2 id="cac-phuong-thuc-cua-lop-thread-thuong-hay-su-dung" class="ftwp-heading"><span id="Cac_phuong_thuc_cua_lop_Thread_thuong_hay_su_dung">Các phương thức của lớp Thread thường hay sử dụng</span></h2>
<ul>
<li><strong>suspend()</strong> : Đây là phương thức làm tạm dừng hoạt động của 1 luồng nào đó bằng các ngưng cung cấp CPU cho luồng này. Để cung cấp lại CPU cho luồng ta sử dụng phương thức resume(). Cần lưu ý 1 điều là ta không thể dừng ngay hoạt động của luồng bằng phương thức này. Phương thức suspend() không dừng ngay tức thì hoạt động của luồng mà sau khi luồng này trả CPU về cho hệ điều hành thì không cấp CPU cho luồng nữa.</li>
<li><strong>resume()</strong> : Đây là phương thức làm cho luồng chạy lại khi luồng bị dừng do phương thức suspend() bên trên. Phương thức này sẽ đưa luồng vào lại lịch điều phối CPU để luồng được cấp CPU chạy lại bình thường.</li>
<li><strong>stop()</strong> : Luồng này sẽ kết thúc phương thức run() bằng cách ném ra 1 ngoại lệ ThreadDeath, điều này cũng sẽ làm luồng kết thúc 1 cách ép buộc. Nếu giả sử, trước khi gọi stop() mà luồng đang nắm giữa 1 đối tượng nào đó hoặc 1 tài nguyên nào đó mà luồng khác đang chờ thì có thể dẫn tới việc sảy ra deadlock.</li>
<li><strong>destroy()</strong> : dừng hẳn luồng.</li>
<li><strong>isAlive()</strong> : Phương thức này kiểm tra xem luồng còn active hay không. Phương thức sẽ trả về true nếu luồng đã được start() và chưa rơi vào trạng thái dead. Nếu phương thức trả về false thì luồng đang ở trạng thái “New Thread” hoặc là đang ở trạng thái “Dead”</li>
<li><strong>yeild()</strong> : Hệ điều hành đa nhiệm sẽ phân phối CPU cho các tiến trình, các luồng theo vòng xoay. Mỗi luồng sẽ được cấp CPU trong 1 khoảng thời gian nhất định, sau đó trả lại CPU cho hệ điều hành (HĐH), HĐH sẽ cấp CPU cho luồng khác. Các luồng sẽ nằm chờ trong hàng đợi Ready để nhận CPU theo thứ tự. Java có cung cấp cho chúng ta 1 phương thức khá đặc biệt là <strong>yeild()</strong>, khi gọi phương thức này luồng sẽ bị ngừng cấp CPU và nhường cho luồng tiếp theo trong hàng chờ Ready. Luồng không phải ngưng cấp CPU như suspend mà chỉ ngưng cấp trong lần nhận CPU đó mà thôi.</li>
<li><strong>sleep(long)</strong> : tạm dừng luồng trong một khoảng thời gian millisecond.</li>
<li><strong>join() </strong>: thông báo rằng hãy chờ thread này hoàn thành rồi thread cha mới được tiếp tục chạy.</li>
<li><strong>join(long)</strong> : Thread cha cần phải đợi millisecond mới được tiếp tục chạy, kể từ lúc gọi join(long). Nếu tham số millis = 0 nghĩa là đợi cho tới khi luồng này kết thúc.</li>
<li><strong>getName()</strong> : Trả về tên của thread.</li>
<li><strong>setName(String name)</strong> : Thay đổi tên của thread.</li>
<li><strong>getId()</strong> : Trả về id của thread.</li>
<li><strong>getState(): </strong>trả về trạng thái của thread.</li>
<li><strong>currentThread()</strong> : Trả về tham chiếu của thread đang được thi hành.</li>
<li><strong>getPriority()</strong> : Trả về mức độ ưu tiên của thread.</li>
<li><strong>setPriority(int)</strong> : Thay đổi mức độ ưu tiên của thread.</li>
<li><strong>isDaemon()</strong> : Kiểm tra nếu thread là một luồng Daemon.</li>
<li><strong>setDaemon(boolean)</strong>: xác định thread là một luồng Daemon hay không.</li>
<li><strong>interrupt()</strong> : làm gián đoạn một luồng trong java. Nếu thread nằm trong trạng thái sleep hoặc wait, nghĩa là sleep() hoặc wait() được gọi ra. Việc gọi phương thức interrupt() trên thread đó sẽ phá vỡ trạng thái sleep hoặc wait và ném ra ngoại lệ InterruptedException. Nếu thread không ở trong trạng thái sleep hoặc wait, việc gọi phương thức interrupt() thực hiện hành vi bình thường và không làm gián đoạn thread nhưng đặt cờ interrupt thành true.</li>
<li><strong>isInterrupted()</strong> : kiểm tra nếu thread đã bị ngắt.</li>
<li><strong>interrupted()</strong> : kiểm tra nếu thread hiện tại đã bị ngắt.</li>
</ul>
<h2 id="mot-so-thong-tin-lien-quan-den-luong" class="ftwp-heading"><span id="Mot_so_thong_tin_lien_quan_den_luong">Một số thông tin liên quan đến luồng</span></h2>
<h3 id="dinh-danh-cua-luong-threadid" class="ftwp-heading"><span id="Dinh_danh_cua_luong_ThreadId">Định danh của luồng (ThreadId)</span></h3>
<p>ThreadId là định danh của luồng, nó dùng để phân biệt với các luồng khác cùng tiến trình hoặc cùng tập luồng. Đây là thông số mà máy ảo java tự tạo ra khi ta tạo luồng nên ta không thể sửa đổi cũng như áp đặt thông số này khi tạo luồng. Nhưng ta có thể lấy được nó thông qua phương thức getId() của lớp Thread</p>
<h3 id="ten-cua-luong-threadname" class="ftwp-heading"><span id="Ten_cua_luong_ThreadName">Tên của luồng (ThreadName)</span></h3>
<p>ThreadName là tên của luồng, đây là thuộc tính mà ta có thể đặt hoặc không đặt cho luồng. Nếu ta không đặt cho luồng thì máy ảo java sẽ tự đặt với quy tắc sau: “Thread-” + Thứ tự luồng được tạo ra, bắt đầu từ 0.</p>
<h3 id="do-uu-tien-cua-luong-priority" class="ftwp-heading"><span id="Do_uu_tien_cua_luong_Priority">Độ ưu tiên của luồng (Priority)</span></h3>
<p>Như đã nói ở phần trước, mỗi luồng có 1 độ ưu tiên nhất định. Đây sẽ là thông số quyết định mức ưu tiên khi cấp phát CPU cho các luồng.</p>
<p>Trong java, đế đặt độ ưu tiên cho 1 luồng ta dùng phương thức: <strong>void setPriority(int newPriority)</strong></p>
<ul>
<li>int newPriority : Là giá trị từ 1 đến 10.</li>
</ul>
<p>Java có định nghĩa sẵn 3 mức ưu tiên chuẩn như sau:</p>
<ul>
<li>Thread.<strong>MIN_PRIORITY</strong> (giá trị <strong>01</strong>)</li>
<li>hread.<strong>NORM_PRIORITY</strong> (giá trị <strong>05</strong>)</li>
<li>Thread.<strong>MAX_PRIORITY</strong> (giá trị <strong>10</strong>)</li>
</ul>
<p>Để lấy độ ưu tiên của 1 luồng, ta dùng phương thức: <strong>int getPriority()</strong></p>
<h3 id="vi-du-minh-hoa" class="ftwp-heading"><span id="Vi_du_minh_hoa">Ví dụ minh họa</span></h3>
<div class="code-content">
<div class="code-expandContent">
<pre class=" prettyprinted"><span class="typ">WorkingThread</span><span class="pun">.</span><span class="pln">java

</span><span class="kwd">package</span><span class="pln"> com</span><span class="pun">.</span><span class="pln">gpcoder</span><span class="pun">.</span><span class="pln">info</span><span class="pun">;</span>

<span class="kwd">public</span> <span class="kwd">class</span> <span class="typ">WorkingThread</span> <span class="kwd">extends</span> <span class="typ">Thread</span> <span class="pun">{</span><span class="pln">
    </span><span class="kwd">public</span> <span class="typ">WorkingThread</span><span class="pun">(</span><span class="typ">String</span><span class="pln"> name</span><span class="pun">)</span> <span class="pun">{</span><span class="pln">
        </span><span class="kwd">super</span><span class="pun">(</span><span class="pln">name</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="kwd">public</span> <span class="kwd">void</span><span class="pln"> run</span><span class="pun">()</span> <span class="pun">{</span><span class="pln">
        </span><span class="kwd">for</span> <span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span> <span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&amp;</span><span class="pln">lt</span><span class="pun">;</span> <span class="lit">5</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span> <span class="pun">{</span><span class="pln">
            </span><span class="typ">System</span><span class="pun">.</span><span class="kwd">out</span><span class="pun">.</span><span class="pln">printf</span><span class="pun">(</span><span class="str">"Luồng: %s có độ ưu tiên là %d n"</span><span class="pun">,</span><span class="pln"> getName</span><span class="pun">(),</span><span class="pln"> getPriority</span><span class="pun">());</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
    </span><span class="pun">}</span>
<span class="pun">}</span></pre>
</div>
<div class="bbCodeBlock-expandLink"><a class="expand">Xem tiếp...</a></div>
</div>
<p>ThreadInfoExample.java</p>
<div class="code-content">
<div class="code-expandContent">
<pre class=" prettyprinted"><span class="kwd">package</span><span class="pln"> com</span><span class="pun">.</span><span class="pln">gpcoder</span><span class="pun">.</span><span class="pln">info</span><span class="pun">;</span>

<span class="kwd">public</span> <span class="kwd">class</span> <span class="typ">ThreadInfoExample</span> <span class="pun">{</span><span class="pln">

    </span><span class="kwd">public</span> <span class="kwd">static</span> <span class="kwd">void</span><span class="pln"> main</span><span class="pun">(</span><span class="typ">String</span><span class="pun">[]</span><span class="pln"> args</span><span class="pun">)</span> <span class="pun">{</span><span class="pln">
        </span><span class="typ">Thread</span><span class="pln"> t1 </span><span class="pun">=</span> <span class="kwd">new</span> <span class="typ">WorkingThread</span><span class="pun">(</span><span class="str">"Luồng 1"</span><span class="pun">);</span><span class="pln">
        </span><span class="typ">Thread</span><span class="pln"> t2 </span><span class="pun">=</span> <span class="kwd">new</span> <span class="typ">WorkingThread</span><span class="pun">(</span><span class="str">"Luồng 2"</span><span class="pun">);</span><span class="pln">
        </span><span class="typ">Thread</span><span class="pln"> t3 </span><span class="pun">=</span> <span class="kwd">new</span> <span class="typ">WorkingThread</span><span class="pun">(</span><span class="str">"Luồng 3"</span><span class="pun">);</span><span class="pln">

        </span><span class="typ">System</span><span class="pun">.</span><span class="kwd">out</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="str">"ID luồng 1: "</span> <span class="pun">+</span><span class="pln"> t1</span><span class="pun">.</span><span class="pln">getId</span><span class="pun">());</span><span class="pln">
        </span><span class="typ">System</span><span class="pun">.</span><span class="kwd">out</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="str">"ID luồng 2: "</span> <span class="pun">+</span><span class="pln"> t2</span><span class="pun">.</span><span class="pln">getId</span><span class="pun">());</span><span class="pln">
        </span><span class="typ">System</span><span class="pun">.</span><span class="kwd">out</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="str">"ID luồng 3: "</span> <span class="pun">+</span><span class="pln"> t3</span><span class="pun">.</span><span class="pln">getId</span><span class="pun">());</span><span class="pln">

        t1</span><span class="pun">.</span><span class="pln">setPriority</span><span class="pun">(</span><span class="lit">1</span><span class="pun">);</span><span class="pln">
        t2</span><span class="pun">.</span><span class="pln">setPriority</span><span class="pun">(</span><span class="lit">5</span><span class="pun">);</span><span class="pln">
        t3</span><span class="pun">.</span><span class="pln">setPriority</span><span class="pun">(</span><span class="lit">10</span><span class="pun">);</span><span class="pln">

        t1</span><span class="pun">.</span><span class="pln">start</span><span class="pun">();</span><span class="pln">
        t2</span><span class="pun">.</span><span class="pln">start</span><span class="pun">();</span><span class="pln">
        t3</span><span class="pun">.</span><span class="pln">start</span><span class="pun">();</span><span class="pln">
    </span><span class="pun">}</span>

<span class="pun">}</span></pre>
</div>
<div class="bbCodeBlock-expandLink"><a class="expand">Xem tiếp...</a></div>
</div>
<div>
<div id="highlighter_925320" class="syntaxhighlighter code-block java"></div>
</div>
<p>Kết quả thực thi chương trình trên:</p>
<div class="code-content">
<div class="code-expandContent">
<pre class=" prettyprinted"><span class="pln">ID lu</span><span class="pun">ồ</span><span class="pln">ng </span><span class="lit">1</span><span class="pun">:</span> <span class="lit">10</span><span class="pln">
ID lu</span><span class="pun">ồ</span><span class="pln">ng </span><span class="lit">2</span><span class="pun">:</span> <span class="lit">11</span><span class="pln">
ID lu</span><span class="pun">ồ</span><span class="pln">ng </span><span class="lit">3</span><span class="pun">:</span> <span class="lit">12</span>
<span class="typ">Lu</span><span class="pun">ồ</span><span class="pln">ng</span><span class="pun">:</span> <span class="typ">Lu</span><span class="pun">ồ</span><span class="pln">ng </span><span class="lit">2</span><span class="pln"> c</span><span class="pun">ó</span> <span class="pun">độ</span> <span class="pun">ư</span><span class="pln">u ti</span><span class="pun">ê</span><span class="pln">n l</span><span class="pun">à</span> <span class="lit">5</span>
<span class="typ">Lu</span><span class="pun">ồ</span><span class="pln">ng</span><span class="pun">:</span> <span class="typ">Lu</span><span class="pun">ồ</span><span class="pln">ng </span><span class="lit">2</span><span class="pln"> c</span><span class="pun">ó</span> <span class="pun">độ</span> <span class="pun">ư</span><span class="pln">u ti</span><span class="pun">ê</span><span class="pln">n l</span><span class="pun">à</span> <span class="lit">5</span>
<span class="typ">Lu</span><span class="pun">ồ</span><span class="pln">ng</span><span class="pun">:</span> <span class="typ">Lu</span><span class="pun">ồ</span><span class="pln">ng </span><span class="lit">2</span><span class="pln"> c</span><span class="pun">ó</span> <span class="pun">độ</span> <span class="pun">ư</span><span class="pln">u ti</span><span class="pun">ê</span><span class="pln">n l</span><span class="pun">à</span> <span class="lit">5</span>
<span class="typ">Lu</span><span class="pun">ồ</span><span class="pln">ng</span><span class="pun">:</span> <span class="typ">Lu</span><span class="pun">ồ</span><span class="pln">ng </span><span class="lit">2</span><span class="pln"> c</span><span class="pun">ó</span> <span class="pun">độ</span> <span class="pun">ư</span><span class="pln">u ti</span><span class="pun">ê</span><span class="pln">n l</span><span class="pun">à</span> <span class="lit">5</span>
<span class="typ">Lu</span><span class="pun">ồ</span><span class="pln">ng</span><span class="pun">:</span> <span class="typ">Lu</span><span class="pun">ồ</span><span class="pln">ng </span><span class="lit">2</span><span class="pln"> c</span><span class="pun">ó</span> <span class="pun">độ</span> <span class="pun">ư</span><span class="pln">u ti</span><span class="pun">ê</span><span class="pln">n l</span><span class="pun">à</span> <span class="lit">5</span>
<span class="typ">Lu</span><span class="pun">ồ</span><span class="pln">ng</span><span class="pun">:</span> <span class="typ">Lu</span><span class="pun">ồ</span><span class="pln">ng </span><span class="lit">1</span><span class="pln"> c</span><span class="pun">ó</span> <span class="pun">độ</span> <span class="pun">ư</span><span class="pln">u ti</span><span class="pun">ê</span><span class="pln">n l</span><span class="pun">à</span> <span class="lit">1</span>
<span class="typ">Lu</span><span class="pun">ồ</span><span class="pln">ng</span><span class="pun">:</span> <span class="typ">Lu</span><span class="pun">ồ</span><span class="pln">ng </span><span class="lit">3</span><span class="pln"> c</span><span class="pun">ó</span> <span class="pun">độ</span> <span class="pun">ư</span><span class="pln">u ti</span><span class="pun">ê</span><span class="pln">n l</span><span class="pun">à</span> <span class="lit">10</span>
<span class="typ">Lu</span><span class="pun">ồ</span><span class="pln">ng</span><span class="pun">:</span> <span class="typ">Lu</span><span class="pun">ồ</span><span class="pln">ng </span><span class="lit">3</span><span class="pln"> c</span><span class="pun">ó</span> <span class="pun">độ</span> <span class="pun">ư</span><span class="pln">u ti</span><span class="pun">ê</span><span class="pln">n l</span><span class="pun">à</span> <span class="lit">10</span>
<span class="typ">Lu</span><span class="pun">ồ</span><span class="pln">ng</span><span class="pun">:</span> <span class="typ">Lu</span><span class="pun">ồ</span><span class="pln">ng </span><span class="lit">3</span><span class="pln"> c</span><span class="pun">ó</span> <span class="pun">độ</span> <span class="pun">ư</span><span class="pln">u ti</span><span class="pun">ê</span><span class="pln">n l</span><span class="pun">à</span> <span class="lit">10</span>
<span class="typ">Lu</span><span class="pun">ồ</span><span class="pln">ng</span><span class="pun">:</span> <span class="typ">Lu</span><span class="pun">ồ</span><span class="pln">ng </span><span class="lit">3</span><span class="pln"> c</span><span class="pun">ó</span> <span class="pun">độ</span> <span class="pun">ư</span><span class="pln">u ti</span><span class="pun">ê</span><span class="pln">n l</span><span class="pun">à</span> <span class="lit">10</span>
<span class="typ">Lu</span><span class="pun">ồ</span><span class="pln">ng</span><span class="pun">:</span> <span class="typ">Lu</span><span class="pun">ồ</span><span class="pln">ng </span><span class="lit">3</span><span class="pln"> c</span><span class="pun">ó</span> <span class="pun">độ</span> <span class="pun">ư</span><span class="pln">u ti</span><span class="pun">ê</span><span class="pln">n l</span><span class="pun">à</span> <span class="lit">10</span>
<span class="typ">Lu</span><span class="pun">ồ</span><span class="pln">ng</span><span class="pun">:</span> <span class="typ">Lu</span><span class="pun">ồ</span><span class="pln">ng </span><span class="lit">1</span><span class="pln"> c</span><span class="pun">ó</span> <span class="pun">độ</span> <span class="pun">ư</span><span class="pln">u ti</span><span class="pun">ê</span><span class="pln">n l</span><span class="pun">à</span> <span class="lit">1</span>
<span class="typ">Lu</span><span class="pun">ồ</span><span class="pln">ng</span><span class="pun">:</span> <span class="typ">Lu</span><span class="pun">ồ</span><span class="pln">ng </span><span class="lit">1</span><span class="pln"> c</span><span class="pun">ó</span> <span class="pun">độ</span> <span class="pun">ư</span><span class="pln">u ti</span><span class="pun">ê</span><span class="pln">n l</span><span class="pun">à</span> <span class="lit">1</span>
<span class="typ">Lu</span><span class="pun">ồ</span><span class="pln">ng</span><span class="pun">:</span> <span class="typ">Lu</span><span class="pun">ồ</span><span class="pln">ng </span><span class="lit">1</span><span class="pln"> c</span><span class="pun">ó</span> <span class="pun">độ</span> <span class="pun">ư</span><span class="pln">u ti</span><span class="pun">ê</span><span class="pln">n l</span><span class="pun">à</span> <span class="lit">1</span>
<span class="typ">Lu</span><span class="pun">ồ</span><span class="pln">ng</span><span class="pun">:</span> <span class="typ">Lu</span><span class="pun">ồ</span><span class="pln">ng </span><span class="lit">1</span><span class="pln"> c</span><span class="pun">ó</span> <span class="pun">độ</span> <span class="pun">ư</span><span class="pln">u ti</span><span class="pun">ê</span><span class="pln">n l</span><span class="pun">à</span> <span class="lit">1</span></pre>
</div>
<div class="bbCodeBlock-expandLink"><a class="expand">Xem tiếp...</a></div>
</div>
<h2 id="su-dung-phuong-thuc-sleep" class="ftwp-heading"><span id="Su_dung_phuong_thuc_sleep">Sử dụng phương thức sleep()</span></h2>
<p>Phương thức sleep() của lớp Thread được sử dụng để tạm ngừng một thread cho một khoảng thời gian nhất định.</p>
<p>Ví dụ chương trình in ra số từ 1 – 5, tạm ngừng 500 ms trước khi in chữ số tiếp theo.</p>
<div class="code-content">
<div class="code-expandContent">
<pre class=" prettyprinted"><span class="kwd">package</span><span class="pln"> com</span><span class="pun">.</span><span class="pln">gpcoder</span><span class="pun">.</span><span class="pln">sleep</span><span class="pun">;</span>

<span class="kwd">public</span> <span class="kwd">class</span> <span class="typ">SleepMethodExample</span> <span class="kwd">extends</span> <span class="typ">Thread</span> <span class="pun">{</span><span class="pln">

    </span><span class="kwd">public</span> <span class="kwd">void</span><span class="pln"> run</span><span class="pun">()</span> <span class="pun">{</span><span class="pln">
        </span><span class="kwd">for</span> <span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span> <span class="lit">1</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;=</span> <span class="lit">5</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span> <span class="pun">{</span><span class="pln">
            </span><span class="typ">System</span><span class="pun">.</span><span class="kwd">out</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="pln">i</span><span class="pun">);</span><span class="pln">
            </span><span class="kwd">try</span> <span class="pun">{</span><span class="pln">
                </span><span class="typ">Thread</span><span class="pun">.</span><span class="pln">sleep</span><span class="pun">(</span><span class="lit">500</span><span class="pun">);</span><span class="pln">
            </span><span class="pun">}</span> <span class="kwd">catch</span> <span class="pun">(</span><span class="typ">InterruptedException</span><span class="pln"> e</span><span class="pun">)</span> <span class="pun">{</span><span class="pln">
                e</span><span class="pun">.</span><span class="pln">printStackTrace</span><span class="pun">();</span><span class="pln">
            </span><span class="pun">}</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="kwd">public</span> <span class="kwd">static</span> <span class="kwd">void</span><span class="pln"> main</span><span class="pun">(</span><span class="typ">String</span><span class="pln"> args</span><span class="pun">[])</span> <span class="pun">{</span><span class="pln">
        </span><span class="typ">SleepMethodExample</span><span class="pln"> t1 </span><span class="pun">=</span> <span class="kwd">new</span> <span class="typ">SleepMethodExample</span><span class="pun">();</span><span class="pln">
        t1</span><span class="pun">.</span><span class="pln">start</span><span class="pun">();</span><span class="pln">
    </span><span class="pun">}</span>

<span class="pun">}</span></pre>
</div>
<div class="bbCodeBlock-expandLink"><a class="expand">Xem tiếp...</a></div>
</div>
<h2 id="su-dung-join-va-joinlong" class="ftwp-heading"><span id="Su_dung_join_vajoinlong">Sử dụng join() và join(long)</span></h2>
<p><strong>join()</strong> : thông báo rằng hãy chờ thread này hoàn thành rồi thread cha mới được tiếp tục chạy.</p>
<p>Ví dụ:</p>
<div class="code-content">
<div class="code-expandContent">
<pre class=" prettyprinted"><span class="kwd">package</span><span class="pln"> com</span><span class="pun">.</span><span class="pln">gpcoder</span><span class="pun">.</span><span class="kwd">join</span><span class="pun">;</span>

<span class="kwd">public</span> <span class="kwd">class</span> <span class="typ">UsingJoinMethod</span> <span class="kwd">extends</span> <span class="typ">Thread</span> <span class="pun">{</span><span class="pln">

    </span><span class="kwd">public</span> <span class="typ">UsingJoinMethod</span><span class="pun">(</span><span class="typ">String</span><span class="pln"> name</span><span class="pun">)</span> <span class="pun">{</span><span class="pln">
        </span><span class="kwd">super</span><span class="pun">(</span><span class="pln">name</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="lit">@Override</span><span class="pln">
    </span><span class="kwd">public</span> <span class="kwd">void</span><span class="pln"> run</span><span class="pun">()</span> <span class="pun">{</span><span class="pln">
        </span><span class="typ">System</span><span class="pun">.</span><span class="kwd">out</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="pln">getName</span><span class="pun">());</span><span class="pln">
        </span><span class="kwd">for</span> <span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span> <span class="lit">1</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;=</span> <span class="lit">5</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span> <span class="pun">{</span><span class="pln">
            </span><span class="kwd">try</span> <span class="pun">{</span><span class="pln">
                </span><span class="typ">System</span><span class="pun">.</span><span class="kwd">out</span><span class="pun">.</span><span class="kwd">print</span><span class="pun">(</span><span class="pln">i </span><span class="pun">+</span> <span class="str">" "</span><span class="pun">);</span><span class="pln">
                </span><span class="typ">Thread</span><span class="pun">.</span><span class="pln">sleep</span><span class="pun">(</span><span class="lit">300</span><span class="pun">);</span><span class="pln">
            </span><span class="pun">}</span> <span class="kwd">catch</span> <span class="pun">(</span><span class="typ">InterruptedException</span><span class="pln"> ie</span><span class="pun">)</span> <span class="pun">{</span><span class="pln">
                </span><span class="typ">System</span><span class="pun">.</span><span class="kwd">out</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="pln">ie</span><span class="pun">.</span><span class="pln">toString</span><span class="pun">());</span><span class="pln">
            </span><span class="pun">}</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
        </span><span class="typ">System</span><span class="pun">.</span><span class="kwd">out</span><span class="pun">.</span><span class="pln">println</span><span class="pun">();</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="kwd">public</span> <span class="kwd">static</span> <span class="kwd">void</span><span class="pln"> main</span><span class="pun">(</span><span class="typ">String</span><span class="pun">[]</span><span class="pln"> args</span><span class="pun">)</span> <span class="kwd">throws</span> <span class="typ">InterruptedException</span> <span class="pun">{</span><span class="pln">
        </span><span class="typ">UsingJoinMethod</span><span class="pln"> t1 </span><span class="pun">=</span> <span class="kwd">new</span> <span class="typ">UsingJoinMethod</span><span class="pun">(</span><span class="str">"Thread 1"</span><span class="pun">);</span><span class="pln">
        </span><span class="typ">UsingJoinMethod</span><span class="pln"> t2 </span><span class="pun">=</span> <span class="kwd">new</span> <span class="typ">UsingJoinMethod</span><span class="pun">(</span><span class="str">"Thread 2"</span><span class="pun">);</span><span class="pln">
        t1</span><span class="pun">.</span><span class="pln">start</span><span class="pun">();</span><span class="pln">
        t1</span><span class="pun">.</span><span class="kwd">join</span><span class="pun">();</span><span class="pln">
        t2</span><span class="pun">.</span><span class="pln">start</span><span class="pun">();</span><span class="pln">
        </span><span class="typ">System</span><span class="pun">.</span><span class="kwd">out</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="str">"Main Thread Finished"</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span>
<span class="pun">}</span></pre>
</div>
<div class="bbCodeBlock-expandLink"><a class="expand">Xem tiếp...</a></div>
</div>
<p>Thực thi chương trình trên:</p>
<pre class=" prettyprinted"><span class="typ">Thread</span> <span class="lit">1</span>
<span class="lit">1</span> <span class="lit">2</span> <span class="lit">3</span> <span class="lit">4</span> <span class="lit">5</span>
<span class="typ">Main</span> <span class="typ">Thread</span> <span class="typ">Finished</span>
<span class="typ">Thread</span> <span class="lit">2</span>
<span class="lit">1</span> <span class="lit">2</span> <span class="lit">3</span> <span class="lit">4</span> <span class="lit">5</span></pre>
<p><strong>join(long)</strong> : Thread cha cần phải đợi millisecond mới được tiếp tục chạy, kể từ lúc gọi join(long). Nếu tham số millis = 0 nghĩa là đợi cho tới khi luồng này kết thúc.</p>
<div class="code-content">
<div class="code-expandContent">
<pre class=" prettyprinted"><span class="kwd">package</span><span class="pln"> com</span><span class="pun">.</span><span class="pln">gpcoder</span><span class="pun">.</span><span class="kwd">join</span><span class="pun">;</span>

<span class="kwd">public</span> <span class="kwd">class</span> <span class="typ">UsingJoinMethod2</span> <span class="kwd">extends</span> <span class="typ">Thread</span> <span class="pun">{</span><span class="pln">

    </span><span class="kwd">public</span> <span class="typ">UsingJoinMethod2</span><span class="pun">(</span><span class="typ">String</span><span class="pln"> name</span><span class="pun">)</span> <span class="pun">{</span><span class="pln">
        </span><span class="kwd">super</span><span class="pun">(</span><span class="pln">name</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="lit">@Override</span><span class="pln">
    </span><span class="kwd">public</span> <span class="kwd">void</span><span class="pln"> run</span><span class="pun">()</span> <span class="pun">{</span><span class="pln">
        </span><span class="typ">System</span><span class="pun">.</span><span class="kwd">out</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="pln">getName</span><span class="pun">());</span><span class="pln">
        </span><span class="kwd">for</span> <span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span> <span class="lit">1</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;=</span> <span class="lit">5</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span> <span class="pun">{</span><span class="pln">
            </span><span class="kwd">try</span> <span class="pun">{</span><span class="pln">
                </span><span class="typ">System</span><span class="pun">.</span><span class="kwd">out</span><span class="pun">.</span><span class="kwd">print</span><span class="pun">(</span><span class="pln">i </span><span class="pun">+</span> <span class="str">" "</span><span class="pun">);</span><span class="pln">
                </span><span class="typ">Thread</span><span class="pun">.</span><span class="pln">sleep</span><span class="pun">(</span><span class="lit">300</span><span class="pun">);</span><span class="pln">
            </span><span class="pun">}</span> <span class="kwd">catch</span> <span class="pun">(</span><span class="typ">InterruptedException</span><span class="pln"> ie</span><span class="pun">)</span> <span class="pun">{</span><span class="pln">
                </span><span class="typ">System</span><span class="pun">.</span><span class="kwd">out</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="pln">ie</span><span class="pun">.</span><span class="pln">toString</span><span class="pun">());</span><span class="pln">
            </span><span class="pun">}</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
        </span><span class="typ">System</span><span class="pun">.</span><span class="kwd">out</span><span class="pun">.</span><span class="pln">println</span><span class="pun">();</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="kwd">public</span> <span class="kwd">static</span> <span class="kwd">void</span><span class="pln"> main</span><span class="pun">(</span><span class="typ">String</span><span class="pun">[]</span><span class="pln"> args</span><span class="pun">)</span> <span class="kwd">throws</span> <span class="typ">InterruptedException</span> <span class="pun">{</span><span class="pln">
        </span><span class="typ">UsingJoinMethod2</span><span class="pln"> t1 </span><span class="pun">=</span> <span class="kwd">new</span> <span class="typ">UsingJoinMethod2</span><span class="pun">(</span><span class="str">"Thread 1"</span><span class="pun">);</span><span class="pln">
        </span><span class="typ">UsingJoinMethod2</span><span class="pln"> t2 </span><span class="pun">=</span> <span class="kwd">new</span> <span class="typ">UsingJoinMethod2</span><span class="pun">(</span><span class="str">"Thread 2"</span><span class="pun">);</span><span class="pln">
        t1</span><span class="pun">.</span><span class="pln">start</span><span class="pun">();</span><span class="pln">

        </span><span class="com">// Main Thread phải chờ 450ms mới được tiếp tục chạy.</span><span class="pln">
        </span><span class="com">// Không nhất thiết phải chờ Thread t1 kết thúc</span><span class="pln">
        t1</span><span class="pun">.</span><span class="kwd">join</span><span class="pun">(</span><span class="lit">450</span><span class="pun">);</span><span class="pln">

        t2</span><span class="pun">.</span><span class="pln">start</span><span class="pun">();</span><span class="pln">
        </span><span class="typ">System</span><span class="pun">.</span><span class="kwd">out</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="str">"Main Thread Finished"</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span>
<span class="pun">}</span></pre>
</div>
<div class="bbCodeBlock-expandLink"><a class="expand">Xem tiếp...</a></div>
</div>
<p>Thực thi chương trình trên:</p>
<pre class=" prettyprinted"><span class="typ">Thread</span> <span class="lit">1</span>
<span class="lit">1</span> <span class="lit">2</span> <span class="typ">Main</span> <span class="typ">Thread</span> <span class="typ">Finished</span>
<span class="typ">Thread</span> <span class="lit">2</span>
<span class="lit">1</span> <span class="lit">3</span> <span class="lit">2</span> <span class="lit">4</span> <span class="lit">3</span> <span class="lit">5</span> <span class="lit">4</span>
<span class="lit">5</span></pre>
<h2 id="xu-ly-ngoai-le-cho-thread" class="ftwp-heading"><span id="Xu_ly_ngoai_le_cho_Thread">Xử lý ngoại lệ cho Thread</span></h2>
<p>Phương thức Thread.setDefaultUncaughtExceptionHandler() thiết lập mặc định xử lý khi luồng đột ngột chấm dứt do một ngoại lệ xảy ra mà không có xử lý khác đã được xác định cho luồng đó.</p>
<p>Ví dụ:</p>
<div class="code-content">
<div class="code-expandContent">
<pre class=" prettyprinted"><span class="kwd">package</span><span class="pln"> com</span><span class="pun">.</span><span class="pln">gpcoder</span><span class="pun">.</span><span class="pln">exception</span><span class="pun">;</span>

<span class="kwd">import</span><span class="pln"> java</span><span class="pun">.</span><span class="pln">util</span><span class="pun">.</span><span class="typ">Random</span><span class="pun">;</span>

<span class="kwd">public</span> <span class="kwd">class</span> <span class="typ">WorkingThread</span> <span class="kwd">implements</span> <span class="typ">Runnable</span> <span class="pun">{</span><span class="pln">

    </span><span class="lit">@Override</span><span class="pln">
    </span><span class="kwd">public</span> <span class="kwd">void</span><span class="pln"> run</span><span class="pun">()</span> <span class="pun">{</span><span class="pln">
        </span><span class="kwd">while</span> <span class="pun">(</span><span class="kwd">true</span><span class="pun">)</span> <span class="pun">{</span><span class="pln">
            processSomething</span><span class="pun">();</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="kwd">private</span> <span class="kwd">void</span><span class="pln"> processSomething</span><span class="pun">()</span> <span class="pun">{</span><span class="pln">
        </span><span class="kwd">try</span> <span class="pun">{</span><span class="pln">
            </span><span class="typ">System</span><span class="pun">.</span><span class="kwd">out</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="str">"Processing working thread"</span><span class="pun">);</span><span class="pln">
            </span><span class="typ">Thread</span><span class="pun">.</span><span class="pln">sleep</span><span class="pun">(</span><span class="lit">500</span><span class="pun">);</span><span class="pln">
        </span><span class="pun">}</span> <span class="kwd">catch</span> <span class="pun">(</span><span class="typ">InterruptedException</span><span class="pln"> e</span><span class="pun">)</span> <span class="pun">{</span><span class="pln">
            e</span><span class="pun">.</span><span class="pln">printStackTrace</span><span class="pun">();</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">

        </span><span class="typ">Random</span><span class="pln"> r </span><span class="pun">=</span> <span class="kwd">new</span> <span class="typ">Random</span><span class="pun">();</span><span class="pln">
        </span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> r</span><span class="pun">.</span><span class="pln">nextInt</span><span class="pun">(</span><span class="lit">100</span><span class="pun">);</span><span class="pln">
        </span><span class="kwd">if</span> <span class="pun">(</span><span class="pln">i </span><span class="pun">&gt;</span> <span class="lit">70</span><span class="pun">)</span> <span class="pun">{</span><span class="pln">
            </span><span class="kwd">throw</span> <span class="kwd">new</span> <span class="typ">RuntimeException</span><span class="pun">(</span><span class="str">"Simulate an exception was not handled in the thread"</span><span class="pun">);</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
    </span><span class="pun">}</span>

<span class="pun">}</span></pre>
</div>
<div class="bbCodeBlock-expandLink"><a class="expand">Xem tiếp...</a></div>
</div>
<p>Chương trình minh họa xử lý Thread Exception</p>
<div class="code-content">
<div class="code-expandContent">
<pre class=" prettyprinted"><span class="kwd">package</span><span class="pln"> com</span><span class="pun">.</span><span class="pln">gpcoder</span><span class="pun">.</span><span class="pln">exception</span><span class="pun">;</span>

<span class="kwd">public</span> <span class="kwd">class</span> <span class="typ">ThreadExceptionDemo</span> <span class="pun">{</span><span class="pln">

    </span><span class="kwd">public</span> <span class="kwd">static</span> <span class="kwd">void</span><span class="pln"> main</span><span class="pun">(</span><span class="typ">String</span><span class="pun">[]</span><span class="pln"> args</span><span class="pun">)</span> <span class="pun">{</span><span class="pln">
        </span><span class="typ">System</span><span class="pun">.</span><span class="kwd">out</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="str">"==&gt; Main thread running..."</span><span class="pun">);</span><span class="pln">

        </span><span class="typ">Thread</span><span class="pln"> thread </span><span class="pun">=</span> <span class="kwd">new</span> <span class="typ">Thread</span><span class="pun">(</span><span class="kwd">new</span> <span class="typ">WorkingThread</span><span class="pun">());</span><span class="pln">
        </span><span class="typ">Thread</span><span class="pun">.</span><span class="pln">setDefaultUncaughtExceptionHandler</span><span class="pun">(</span><span class="kwd">new</span> <span class="typ">Thread</span><span class="pun">.</span><span class="typ">UncaughtExceptionHandler</span><span class="pun">()</span> <span class="pun">{</span><span class="pln">
            </span><span class="lit">@Override</span><span class="pln">
            </span><span class="kwd">public</span> <span class="kwd">void</span><span class="pln"> uncaughtException</span><span class="pun">(</span><span class="typ">Thread</span><span class="pln"> t</span><span class="pun">,</span> <span class="typ">Throwable</span><span class="pln"> e</span><span class="pun">)</span> <span class="pun">{</span><span class="pln">
                </span><span class="typ">System</span><span class="pun">.</span><span class="kwd">out</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="str">"#Thread: "</span> <span class="pun">+</span><span class="pln"> t</span><span class="pun">);</span><span class="pln">
                </span><span class="typ">System</span><span class="pun">.</span><span class="kwd">out</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="str">"#Thread exception message: "</span> <span class="pun">+</span><span class="pln"> e</span><span class="pun">.</span><span class="pln">getMessage</span><span class="pun">());</span><span class="pln">
            </span><span class="pun">}</span><span class="pln">
        </span><span class="pun">});</span><span class="pln">

        thread</span><span class="pun">.</span><span class="pln">start</span><span class="pun">();</span><span class="pln">
        </span><span class="typ">System</span><span class="pun">.</span><span class="kwd">out</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="str">"==&gt; Main thread end!!!"</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span>
<span class="pun">}</span></pre>
</div>
<div class="bbCodeBlock-expandLink"><a class="expand">Xem tiếp...</a></div>
</div>
<p>Thực thi chương trình trên:</p>
<div class="code-content">
<div class="code-expandContent">
<pre class=" prettyprinted"><span class="pun">==&gt;</span> <span class="typ">Main</span><span class="pln"> thread running</span><span class="pun">...</span>
<span class="pun">==&gt;</span> <span class="typ">Main</span><span class="pln"> thread </span><span class="kwd">end</span><span class="pun">!!!</span>
<span class="typ">Processing</span><span class="pln"> working thread
</span><span class="typ">Processing</span><span class="pln"> working thread
</span><span class="typ">Processing</span><span class="pln"> working thread
</span><span class="typ">Processing</span><span class="pln"> working thread
</span><span class="typ">Processing</span><span class="pln"> working thread
</span><span class="typ">Processing</span><span class="pln"> working thread
</span><span class="com">#Thread: Thread[Thread-0,5,main]</span>
<span class="com">#Thread exception message: Have a problem...</span></pre>
</div>
<div class="bbCodeBlock-expandLink"><a class="expand">Xem tiếp...</a></div>
</div>
<p><em>Trên đây là những kiến thức cơ bản về luồng (thread) và đa luồng (Multi-thread) trong Java. Chúng ta sẽ tiếp tục tìm hiểu về các vấn đề khác của đa luồng trong Java ở các bài viết tiếp theo. Cám ơn các bạn đã quan tâm và theo dõi bài viết.</em></p>
<p><ins class="adsbygoogle" data-ad-format="fluid" data-ad-layout-key="-gw-3+1f-3d+2z" data-ad-client="ca-pub-6685026625685470" data-ad-slot="2913704343" data-adsbygoogle-status="done"><ins id="aswift_4_expand"><ins id="aswift_4_anchor"></ins></ins></ins><strong>Tài liệu tham khảo:</strong></p>
<ul>
<li>https://docs.oracle.com/javase/tutorial/essential/concurrency/</li>
<li>https://www.javatpoint.com/multithreading-in-java</li>
<li>https://o7planning.org/vi/10269/huong-dan-lap-trinh-da-luong-trong-java</li>
</ul>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Chương 2: Quản lý các luồng I/O</title>
        <author>
            <name>Trần Huy Phương</name>
        </author>
        <link href="https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-2-quan-ly-cac-luong-io/"/>
        <id>https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-2-quan-ly-cac-luong-io/</id>

        <updated>2024-12-27T19:26:39+07:00</updated>
            <summary>
                <![CDATA[
                    Khái niệm luồng (stream): Một stream có thể được định nghĩa như là một dãy liên tục dữ liệu. Java định nghĩa 2 kiểu luồng: byte và ký tự (phiên bản gốc chỉ định nghĩa kiểu luồng byte, và sau đó luồng ký tự được&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <ul>
<li><strong>Khái niệm luồng (stream)</strong>: Một stream có thể được định nghĩa như là một dãy liên tục dữ liệu. Java định nghĩa 2 kiểu luồng: byte và ký tự (phiên bản gốc chỉ định nghĩa kiểu luồng byte, và sau đó luồng ký tự được thêm vào trong các phiên bản về sau). Luồng ký tự được thiết kế hỗ trợ việc nhập xuất dữ liệu kiểu ký tự (Unicode). Trong một vài trường hợp luồng ký tự sử dụng hiệu quả hơn luồng byte, nhưng ở mức hệ thống thì tất cả những xuất nhập đều phải qui về byte. Luồng ký tự hỗ trợ hiệu quả chỉ đối với việc quản lý, xử lý các ký tự.</li>
</ul>
<h3 id="_luong-byte-1">Luồng Byte:</h3>
<ul>
<li>Các luồng byte được định nghĩa dùng hai lớp phân cấp, mức trên cùng là hai lớp trừu tượng <strong>InputStream</strong> và <strong>OutputStream</strong>, là các lớp cha của các lớp xuất nhập kiểu byte. InputStream định nghĩa những đặc điểm chung cho những luồng nhập byte. OutputStream mô tả cách xử lý của các luồng xuất byte.</li>
</ul>
<figure class="article-img"><img loading="lazy"  title="" src="http://i.imgur.com/TdlBT3Z.png" alt="" data-is-external-image="true"></figure>
<p>Nhìn trong hình, bạn có thể hiểu được quan hệ giữa các class trong IO với nhau. Chúng ta cần quan tâm nhiều đến <strong>FileInputStream</strong> (FileOutputStream) và <strong>BufferedInputStream</strong> (BufferedOutputStream) khi làm việc xuất nhập với file.</p>
<ul>
<li><strong>FileInputStream</strong>: Làm việc với file, Đọc từng byte dữ liệu bằng phương thức read(), khi kết thúc nó trả về giá trị -1. Cách này có tốc độ tương đối chậm. Đọc theo từng byte:</li>
</ul>
<div style="box-sizing: border-box; color: #1b1b1b; font-family: 'Open Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol'; font-size: 18px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: #ffffff; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; position: relative;">
<pre class="language-sh" data-filename=""><code>FileInputStream in = new FileInputStream("data.txt");
while ((byteRead = in.read()) != -1) {
  System.out.println(byteRead);
}
</code></pre>
<button class="v-markdown-it-code-copy" title="Sao chép" data-clipboard-text="FileInputStream in = new FileInputStream(&quot;data.txt&quot;);
while ((byteRead = in.read()) != -1) {
  System.out.println(byteRead);
}
"></button></div>
<p>Đọc theo từng mảng byte.</p>
<div style="box-sizing: border-box; color: #1b1b1b; font-family: 'Open Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol'; font-size: 18px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: #ffffff; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; position: relative;">
<pre class="language-java" data-filename=""><code>//Dữ liệu đọc được lưu vào mảng byteBuf.
//byteRead là số byte đọc được
FileInputStream in = new FileInputStream("data.txt");
byte[] byteBuf = new byte[4096];
while ((byteRead = in.read()) != -1) {
  for(int i = 0; i &lt;= byteRead; i++){
    System.out.println(byteBuf[i]);
  }
}
</code></pre>
<button class="v-markdown-it-code-copy" title="Sao chép" data-clipboard-text="//Dữ liệu đọc được lưu vào mảng byteBuf.
//byteRead là số byte đọc được
FileInputStream in = new FileInputStream(&quot;data.txt&quot;);
byte[] byteBuf = new byte[4096];
while ((byteRead = in.read()) != -1) {
  for(int i = 0; i &lt;= byteRead; i++){
    System.out.println(byteBuf[i]);
  }
}
"></button></div>
<h3 id="_tuy-nhien-dieu-nay-duong-nhu-khong-duoc-khuyen-khich-de-tang-toc-do-bang-viec-su-dung-bo-dem-hay-su-dung-bufferedinputstream-2">Tuy nhiên điều này dường như không được khuyến khích. Để tăng tốc độ bằng việc sử dụng bộ đệm, hãy sử dụng [<strong>BufferedInputStream</strong>].</h3>
<ul>
<li><strong>BufferedInputStream</strong>: Java sử dụng cơ chế nhập/xuất có lập vùng đệm để tạm thời lập cache dữ liệu vào/ra của một dòng. Nó giúp chương trình đọc/ghi lượng dữ liệu nhỏ không ảnh hưởng lớn đến hiệu năng chung của hệ thống. Trong khi thực hiện vào có vùng đệm, một số lượng byte lớn được đọc tại một thời điểm, và lưu trữ trong một vùng đệm nhập. Khi chương trình đọc dòng nhập thì thay vì ra dòng vào để đọc nó đọc từ vùng đệm nhập. Tiến trình lập vùng đệm ra cũng thực hiện tương tự. khi dữ liệu được một chương trình ghi ra dòng ra, dữ liệu ra được lưu trữ trong một vùng đệm ra. Dữ liệu được lưu trữ đến khi vùng đệm đầy hoặc các dòng tra thực hiện xả trống (flush). Cuối cùng liệu ra trong vùng đệm được chuyển đến dòng ra.</li>
</ul>
<p>Lớp này tự động tạo ra và duy trì vùng đệm để hỗ trợ thao tác vào. Nhờ đó chương trình có thể đọc dữ liệu từ dòng từng byte một mà không ảnh hưởng đến tốc độ thực hiện của hệ thống. Bởi lớp <strong>BufferedInputStream</strong> là một bộ lọc, nên có thể áp dụng nó cho một số đối tượng nhất định của lớp InputStream (không nhất thiết chỉ làm việc với file) và cũng có thể phối hợp với các tập tin đầu vào khác. BufferedInputStream được hiểu một phương thức trung gian, tham số truyền vào của nó là một dòng inputstream (ví dụ FileInputStream). Khác với FileInputStream có tham số truyền vào 1 file.</p>
<div style="box-sizing: border-box; color: #1b1b1b; font-family: 'Open Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol'; font-size: 18px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: #ffffff; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; position: relative;">
<pre class="language-sh" data-filename=""><code>BufferedInputStream in = new BufferedInputStream(new FileInputStream("data.txt"));
while ((byteRead = in.read()) != -1) {
  System.out.println(byteRead);
}
</code></pre>
<button class="v-markdown-it-code-copy" title="Sao chép" data-clipboard-text="BufferedInputStream in = new BufferedInputStream(new FileInputStream(&quot;data.txt&quot;));
while ((byteRead = in.read()) != -1) {
  System.out.println(byteRead);
}
"></button></div>
<p>Đọc theo mảng byte:</p>
<div style="box-sizing: border-box; color: #1b1b1b; font-family: 'Open Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol'; font-size: 18px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: #ffffff; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; position: relative;">
<pre class="language-sh" data-filename=""><code>BufferedInputStream in = new BufferedInputStream(new FileInputStream("data.txt"));
byte[] byteBuf = new byte[4096];
while ((byteRead = in.read()) != -1) {
  for(int i = 0; i &lt;= byteRead; i++){
    System.out.println(byteBuf[i]);
  }
}
</code></pre>
<button class="v-markdown-it-code-copy" title="Sao chép" data-clipboard-text="BufferedInputStream in = new BufferedInputStream(new FileInputStream(&quot;data.txt&quot;));
byte[] byteBuf = new byte[4096];
while ((byteRead = in.read()) != -1) {
  for(int i = 0; i &lt;= byteRead; i++){
    System.out.println(byteBuf[i]);
  }
}
"></button></div>
<ul>
<li><strong>Các phương thức của lớp InputStream</strong></li>
</ul>
<table>
<thead>
<tr>
<th>Tên phương thức</th>
<th>Mô tả</th>
</tr>
</thead>
<tbody>
<tr>
<td>read()</td>
<td>Đọc các byte dữ liệu từ một dòng. Nếu như không có byte dữ liệu nào, nó phải chờ. Khi một phương thức phải chờ, các luồng đang thực hiện phải tạm dừng cho đến khi có dữ liệu.</td>
</tr>
<tr>
<td>read (byte [])</td>
<td>Trả về số byte đọc được hay ‘-1’ nếu như đã đọc đến cuối dòng. Nó gây ra ngoại lệ IOException nếu có lỗi xảy ra.</td>
</tr>
<tr>
<td>read (byte [], int, int)</td>
<td>Nó cũng đọc vào một mảng byte. Nó trả về số byte thực sự đọc được cho đến khi kết thúc dòng. Nó gây ra ngoại lệ IOException nếu lỗi xảy ra.</td>
</tr>
<tr>
<td>available()</td>
<td>Phương pháp này trả về số lượng byte có thể đọc được mà không pahỉ chờ. Nó trả về số byte hiện tại có trong dòng. Nó không phải là phương thức tin cậy để thực hiện tiến trình xử lý đầu vào.</td>
</tr>
<tr>
<td>close()</td>
<td>Phương thức này đóng dòng. Nó dùng để giải phóng mọi tài nguyên dòng đã sử dụng. Luôn luôn đóng dòng để chắc chắn rằng dòng xử lý được kết thúc. Nó gây ra ngoại lệ IOException nếu lỗi xảy ra.</td>
</tr>
<tr>
<td>mark()</td>
<td>Đánh dấu vị trí hiện tại của dòng.</td>
</tr>
<tr>
<td>markSupported()</td>
<td>Trả về giá trị boolean chỉ ra rằng dòng có hỗ trợ các khả năng mark và reset hay không. Nó trả về True nếu dòng hỗ trợ ngược lại trả về False.</td>
</tr>
<tr>
<td>reset()</td>
<td>Phương thức này định vị lại dòng theo vị trí được đánh lần cuối cùng. Nó gây ra ngoại lệ IOException nếu lỗi xảy ra.</td>
</tr>
<tr>
<td>skip()</td>
<td>Phương thức này bỏ qua ‘n’ byte dòng vào. "-n" chỉ định số byte được bỏ qua. Nó gây ra ngoại lệ IOException nếu lỗi xảy ra. Phương thức này sử dụng để di chuyển tới vị trí đặc biệt bên trong dòng vào.</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>Các phương thức của lớp OutputStream</strong></li>
</ul>
<table>
<thead>
<tr>
<th>Tên phương thức</th>
<th>Mô tả</th>
</tr>
</thead>
<tbody>
<tr>
<td>write(int)</td>
<td>Phương thức này ghi một byte</td>
</tr>
<tr>
<td>write(byte[])</td>
<td>Phương thức này phong toả cho đến khi một byte được ghi. dòng phải chờ cho đến khi tác vụ ghi hoàn tất. Nó gây ra ngoại lệ IOException nếu lỗi xảy ra.</td>
</tr>
<tr>
<td>write(byte[],int,int)</td>
<td>Phương thức này ghi mảng các byte. Lớp OutputStream định nghĩa ba dạng khác nhau của phương thức để có thể ghi một byte riêng lẻ, một mảng các byte, hay một đoạn của một mảng byte.</td>
</tr>
<tr>
<td>flush()</td>
<td>Phương thức này xả sạch dòng.Đệm dữ liệu được ghi ra dòng. Nó kích hoạt IOException nếu lỗi xảy ra.</td>
</tr>
<tr>
<td>close()</td>
<td>Phương thức đóng dòng.Nó được dùng để giải phóng mọi tài nguyên gắn với dòng. Nó kích hoạt IOException nếu lỗi xảy ra.</td>
</tr>
</tbody>
</table>
<h3 id="_luong-ky-tu-3">Luồng ký tự:</h3>
<p>Trong nhiều trường hợp luồng byte không phải là cách tốt nhất để quản lý nhập xuất dữ liệu ký tự. Trong lập trình Java có kiểu luồng ký tự phục vụ riêng cho việc nhập xuất dữ liệu trên luồng. Mức trên cùng là 2 lớp trừu tường Reader và Writer. Các lớp dẫn xuất từ Reader và Writer hỗ trợ thao tác trên các luồng ký tự Unicode.</p>
<figure class="article-img"><img loading="lazy"  title="" src="http://i.imgur.com/2Ltj8wI.png" alt="" data-is-external-image="true"></figure>
<p>Để thao tác với file, bạn cần quan tâm đến các class <em>FileReader</em> và <em>BufferedReader</em> Ví dụ chỉ sử dụng FileReader</p>
<div style="box-sizing: border-box; color: #1b1b1b; font-family: 'Open Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol'; font-size: 18px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: #ffffff; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; position: relative;">
<pre class="language-sh" data-filename=""><code>//Đọc từng ký tự một
FileReader inputStream = new FileReader("data.txt");
int c;
while ((c = inputStream.read()) != -1) {
  System.out.print((char)c);
}
</code></pre>
<button class="v-markdown-it-code-copy" title="Sao chép" data-clipboard-text="//Đọc từng ký tự một
FileReader inputStream = new FileReader(&quot;data.txt&quot;);
int c;
while ((c = inputStream.read()) != -1) {
  System.out.print((char)c);
}
"></button></div>
<p>Nếu sử dụng BufferedReader</p>
<div style="box-sizing: border-box; color: #1b1b1b; font-family: 'Open Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol'; font-size: 18px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: #ffffff; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; position: relative;">
<pre class="language-sh" data-filename=""><code>//Có thể đọc theo từng dòng
FileReader fin = new FileReader("data.txt");
BufferedReader in = new BufferedReader(fin);
String str;
while ((str = in.readLine()) != null) {
  System.out.println(str);
}
</code></pre>
<button class="v-markdown-it-code-copy" title="Sao chép" data-clipboard-text="//Có thể đọc theo từng dòng
FileReader fin = new FileReader(&quot;data.txt&quot;);
BufferedReader in = new BufferedReader(fin);
String str;
while ((str = in.readLine()) != null) {
  System.out.println(str);
}
"></button></div>
<p>Ví dụ đọc dữ liệu từ hệ thống (Console)</p>
<div style="box-sizing: border-box; color: #1b1b1b; font-family: 'Open Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol'; font-size: 18px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: #ffffff; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; position: relative;">
<pre class="language-sh" data-filename=""><code>BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
System.out.println("Nhập chuỗi ký tự, kết thúc bằng dấu chấm .");
do {
  c = (char) br.read();
  System.out.println(c);
} while (c != '.');
</code></pre>
<button class="v-markdown-it-code-copy" title="Sao chép" data-clipboard-text="BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
System.out.println(&quot;Nhập chuỗi ký tự, kết thúc bằng dấu chấm .&quot;);
do {
  c = (char) br.read();
  System.out.println(c);
} while (c != '.');
"></button></div>
<p>Ở đây, chúng ta không có cách nào xây dựng 1 lớp BufferedReader trực tiếp từ <a href="http://system.in/" target="_blank" rel="noopener">System.in</a> vì thế nên cần chuyển nó thành luồng ký tự bằng cách dùng InputStreamReader để chuyển byte thành ký tự.</p>
<ul>
<li><strong>Các phương thức của lớp Reader</strong></li>
</ul>
<table>
<thead>
<tr>
<th>Phương thức</th>
<th>Mô tả</th>
</tr>
</thead>
<tbody>
<tr>
<td>void close</td>
<td>Đóng luồng</td>
</tr>
<tr>
<td>void mark(int numChars)</td>
<td>Đánh dấu vị trí hiện tại trên luồng</td>
</tr>
<tr>
<td>int read()</td>
<td>Đọc một ký tự</td>
</tr>
<tr>
<td>int read(char buffer[])</td>
<td>đọc buffer.length ký tự và ghi vào buffer</td>
</tr>
<tr>
<td>abstract int read(char buffer[], int offset, int numChars)</td>
<td>Đọc numChars ký tự cho vào vùng đệm buffer tại vị trí buffer[offset]</td>
</tr>
<tr>
<td>boolean ready()</td>
<td>Kiểm tra xem luồng có đọc được không</td>
</tr>
<tr>
<td>void reset()</td>
<td>Dời con trỏ nhập đến vị trí đánh dấu trước đó</td>
</tr>
<tr>
<td>long skip(long numChars</td>
<td>Bỏ qua numChars của luồng nhập</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>Các phương thức của lớp Writer</strong></li>
</ul>
<table>
<thead>
<tr>
<th>abstract void close()</th>
<th>Đóng luồng xuất</th>
</tr>
</thead>
<tbody>
<tr>
<td>void flush()</td>
<td>Dọn dẹp luồng. (Xuất buffer ra)</td>
</tr>
<tr>
<td>void write(int ch)</td>
<td>Ghi một ký tự</td>
</tr>
<tr>
<td>void write(byte buffer[])</td>
<td>Ghi một mảng ký tự</td>
</tr>
<tr>
<td>void write(char buffer[], int offset, int numChars)</td>
<td>Ghi một phần của mảng ký tự</td>
</tr>
<tr>
<td>void write(String str)</td>
<td>Ghi một chuỗi</td>
</tr>
<tr>
<td>void write(String str, int offset, int numChars)</td>
<td>Ghi một phần của chuỗi ký tự</td>
</tr>
</tbody>
</table>
<h3 id="_doc-va-ghi-doi-tuong-trong-java-4">Đọc và ghi đối tượng trong Java</h3>
<p>Trong Java, việc đọc và ghi một object do class ObjectOutputStream và ObjectInputStream đảm nhiệm. Đây là 2 lớp con của lớp java.io.OutputStream và java.io.InputStream. Để đọc ghi theo Object trong Java thì tại class Object đó ta cần đặt giao tiếp java.io.Serializable. Một ví dự đơn giản đọc ghi 1 Object MyStudent như sau:</p>
<div class="v-markdown-content-box" style="box-sizing: border-box; max-height: 300px; padding-bottom: 1rem; cursor: pointer; mask-image: linear-gradient(#000000 60%, transparent); color: #1b1b1b; font-family: 'Open Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol'; font-size: 18px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: #ffffff; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; position: relative;">
<pre class="language-java" data-filename=""><code>public class ReadWriteObject {
    public static void main(String[] args){
        MyStudent myStudent = new MyStudent(); // tao doi tuong myStudent
 
        //Ghi Object vao file
 
        try {   // dat try cacth de tranh ngoai le khi tao va viet File
            FileOutputStream f = new FileOutputStream("student.dat"); // tao file f tro den student.dat
            ObjectOutputStream oStream = new ObjectOutputStream(f); // dung de ghi theo Object vao file f
            oStream.writeObject(myStudent); // ghi MyStudent theo kieu Object vao file
            oStream.close();
        } catch (IOException e) {
            System.out.println("Error Write file");
        }
 
        // doc Object tu file
        MyStudent ms = null;
 
        try {   // dat try cacth de tranh ngoai le khi tao va doc File
            FileInputStream f = new FileInputStream("student.dat"); // tao file f tro den student.dat
            ObjectInputStream inStream = new ObjectInputStream(f);  // dung de doc theo Object vao file f
            // dung inStream doc theo Object, ep kieu tra ve la MyStudent
            ms = (MyStudent) inStream.readObject();
            inStream.close();
        } catch (ClassNotFoundException e) {
            System.out.println("Class not found");
        } catch (IOException e) {
            System.out.println("Error Read file");
        }
 
        // Xuat KQ
        System.out.println("My name is " + ms.name + ". I am " + ms.age + " years old");
    }
}
 
class MyStudent implements Serializable{
    String name = "Nguyen Cong Thanh";
    int age = 21;
}
</code></pre>
<button class="v-markdown-it-code-copy" title="Sao chép" data-clipboard-text="public class ReadWriteObject {
    public static void main(String[] args){
        MyStudent myStudent = new MyStudent(); // tao doi tuong myStudent
 
        //Ghi Object vao file
 
        try {   // dat try cacth de tranh ngoai le khi tao va viet File
            FileOutputStream f = new FileOutputStream(&quot;student.dat&quot;); // tao file f tro den student.dat
            ObjectOutputStream oStream = new ObjectOutputStream(f); // dung de ghi theo Object vao file f
            oStream.writeObject(myStudent); // ghi MyStudent theo kieu Object vao file
            oStream.close();
        } catch (IOException e) {
            System.out.println(&quot;Error Write file&quot;);
        }
 
        // doc Object tu file
        MyStudent ms = null;
 
        try {   // dat try cacth de tranh ngoai le khi tao va doc File
            FileInputStream f = new FileInputStream(&quot;student.dat&quot;); // tao file f tro den student.dat
            ObjectInputStream inStream = new ObjectInputStream(f);  // dung de doc theo Object vao file f
            // dung inStream doc theo Object, ep kieu tra ve la MyStudent
            ms = (MyStudent) inStream.readObject();
            inStream.close();
        } catch (ClassNotFoundException e) {
            System.out.println(&quot;Class not found&quot;);
        } catch (IOException e) {
            System.out.println(&quot;Error Read file&quot;);
        }
 
        // Xuat KQ
        System.out.println(&quot;My name is &quot; + ms.name + &quot;. I am &quot; + ms.age + &quot; years old&quot;);
    }
}
 
class MyStudent implements Serializable{
    String name = &quot;Nguyen Cong Thanh&quot;;
    int age = 21;
}
"></button>
<div class="v-content-flex-center"> </div>
</div>
<h3 id="_tai-lieu-tham-khao-5">Tài liệu tham khảo:</h3>
<p>Link project github: <a href="https://github.com/hoangtien2k3qx1/Java/tree/main/src/main/java/JavaCore/Java_Input_Output" target="_blank" rel="noopener"><strong>https://github.com/hoangtien2k3qx1/Java/tree/main/JavaCore/Java_Input_Output</strong></a></p>
<p>Github: <a href="https://github.com/hoangtien2k3qx1" target="_blank" rel="noopener"><strong>https://github.com/hoangtien2k3qx1</strong></a></p>
            ]]>
        </content>
    </entry>
</feed>
