<!DOCTYPE html><html lang="en-us"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Chương 5: Lập trình socket cho giao thức TCP - Huy Phuong&#x27;s Blog</title><meta name="description" content="Socket được biết đến là cánh cửa giao tiếp giữa hai tiến trình ứng dụng. Socket hỗ trợ nhiều ngôn ngữ (C, java, perl, python,…) cũng như nhiều platform (*nix, Windows,…). Socket được viết bằng các ngôn ngữ khác nhau và chạy trên bất kỳ&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-5-lap-trinh-socket-cho-giao-thuc-tcp/"><link rel="alternate" type="application/atom+xml" href="https://github.com/HuyPhuongVN/PhuongBlog.git/feed.xml"><link rel="alternate" type="application/json" href="https://github.com/HuyPhuongVN/PhuongBlog.git/feed.json"><meta property="og:title" content="Chương 5: Lập trình socket cho giao thức TCP"><meta property="og:image" content="https://github.com/HuyPhuongVN/PhuongBlog.git/media/website/383700-final.jpg"><meta property="og:image:width" content="1920"><meta property="og:image:height" content="1080"><meta property="og:site_name" content="Huy Phuong's Blog"><meta property="og:description" content="Socket được biết đến là cánh cửa giao tiếp giữa hai tiến trình ứng dụng. Socket hỗ trợ nhiều ngôn ngữ (C, java, perl, python,…) cũng như nhiều platform (*nix, Windows,…). Socket được viết bằng các ngôn ngữ khác nhau và chạy trên bất kỳ&hellip;"><meta property="og:url" content="https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-5-lap-trinh-socket-cho-giao-thuc-tcp/"><meta property="og:type" content="article"><link rel="stylesheet" href="https://github.com/HuyPhuongVN/PhuongBlog.git/assets/css/style.css?v=92daebec56bf325fb98046e3d45c1e86"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-5-lap-trinh-socket-cho-giao-thuc-tcp/"},"headline":"Chương 5: Lập trình socket cho giao thức TCP","datePublished":"2024-12-27T19:32+07:00","dateModified":"2024-12-29T12:31+07:00","description":"Socket được biết đến là cánh cửa giao tiếp giữa hai tiến trình ứng dụng. Socket hỗ trợ nhiều ngôn ngữ (C, java, perl, python,…) cũng như nhiều platform (*nix, Windows,…). Socket được viết bằng các ngôn ngữ khác nhau và chạy trên bất kỳ&hellip;","author":{"@type":"Person","name":"Trần Huy Phương","url":"https://github.com/HuyPhuongVN/PhuongBlog.git/rainblog/huyphuong/"},"publisher":{"@type":"Organization","name":"Trần Huy Phương"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body class="post-template"><header class="top js-header"><a class="logo" href="https://github.com/HuyPhuongVN/PhuongBlog.git/">Huy Phuong&#x27;s Blog</a><div class="search"><div class="search__overlay js-search-overlay"><div class="wrapper search__overlay-inner"></div></div><button class="search__btn btn--icon js-search-btn" aria-label="Search"><svg height="18" width="18" role="presentation" focusable="false"><use xlink:href="https://github.com/HuyPhuongVN/PhuongBlog.git/assets/svg/svg-map.svg#search"/></svg></button></div></header><main class="post"><article class="content"><div class="hero hero--noimage"><header class="hero__content"><div class="wrapper"><h1>Chương 5: Lập trình socket cho giao thức TCP</h1><div class="feed__meta content__meta"><a href="https://github.com/HuyPhuongVN/PhuongBlog.git/rainblog/huyphuong/" class="feed__author">Trần Huy Phương</a> <time datetime="2024-12-27T19:32" class="feed__date">December 27, 2024</time></div></div></header></div><div class="entry-wrapper content__entry"><p><strong>Socket được biết đến là cánh cửa giao tiếp giữa hai tiến trình ứng dụng. Socket hỗ trợ nhiều ngôn ngữ (C, java, perl, python,…) cũng như nhiều platform (*nix, Windows,…). Socket được viết bằng các ngôn ngữ khác nhau và chạy trên bất kỳ platform nào đều có thể giao tiếp với nhau. Trong bài viết này mình gửi đến các bạn khái niệm cơ bản về Socket cũng như cách lập trình Socket với các loại giao thức.</strong></p><h3><strong>1. Tổng quan về Socket</strong></h3><p>Trong hệ thống mạng máy tính tồn tại những mô hình tham chiếu có kiến trúc phần tầng (OSI, TCP/IP…) nhằm hỗ trợ chức năng trao đôi thông tin giữa các ứng dụng ở nhiều máy tính khác nhau.</p><h4><img loading="lazy" src="https://s3-sgn09.fptcloud.com/codelearnstorage/Media/Default/Users/tria3ltt_40gmail_2Ecom/socketJavaImage/Annotation%202020-08-08%20132406.jpg" alt="" width="625" height="265" data-is-external-image="true"></h4><p>Dữ liệu bên gửi sẽ được đóng gói (Encapsulation) từ tầng trên đến tầng cuối là tầng vật lí (Physical Layer), sau đó nhờ tầng vật lí này chuyển dữ liệu đến tầng vật lí máy bên nhận, bên nhận tiến hành giải mã (decapsulation) gói dữ kiện từ tầng dưới lên tầng trên cùng, là tầng ứng dụng (application layer).</p><p><img loading="lazy" src="https://s3-sgn09.fptcloud.com/codelearnstorage/Media/Default/Users/tria3ltt_40gmail_2Ecom/socketJavaImage/Annotation%202020-08-08%20160924.jpg" alt="" width="628" height="316" data-is-external-image="true"></p><p>Ở đây, Socket chính là cửa giao tiếp giữa tầng ứng dụng và tầng giao vận (Transport layer). Nói cách khác, Socket là giao diện do ứng dụng tạo ra trên máy trạm, quản lí bởi hệ điều hành qua đó các ứng dụng có thể gửi/nhận thông điệp đến/từ các ứng  dụng khác. Ở đó, Socket sẽ được ràng buộc với một mã số cổng (Port Number) để giúp tầng giao vận định danh được ứng dụng nhận/gửi thông điệp.</p><p>Các bạn có thể thấy ở hình ảnh trên, tầng giao vận có 2 phương thức là TCP (Ttransmission Control Protocol) và UDP (User Datagram Protocol), như vậy socket cơ bản là có 2 loại: Stream Socket sử dụng TCP truyền dòng bytes và Datagram Socket dử dụng UDP truyền gói tin. Với ngôn ngữ lập trình Java, chúng ta được cung cấp 3 loại khác nhau của sockets:</p><ol><li>Stream Socket (TCP) : Tạo luồng dữ liệu hai chiều, đáng tin cậy, có trình tự và không trùng lặp, dữ liệu chỉ được gửi/nhận khi có đã có liên kết. Dùng với Socket Class của java.</li><li>Datagram Socket (UDP): Có thể nhận dữ liệu không theo tình tự, trùng lặp. Dùng với DatagramSocket Class.</li><li>Multicast Socket : cho phép dữ liệu được gửi đến nhiều bên nhận một lúc. Dùng với DatagramSocket Class.</li></ol><p>Socket được hỗ trợ trên nhiều ngôn ngữ như C, Java, Pearl,  Python,…. Sau đây là một ví dụ lập tình socket với Java.</p><h3><strong>2. Lập trình TCP Socket với Java</strong></h3><p>Trong bài viết này mình sẽ nói về lập trình Socket sử dụng TCP.</p><p><img loading="lazy" src="https://s3-sgn09.fptcloud.com/codelearnstorage/Media/Default/Users/tria3ltt_40gmail_2Ecom/socketJavaImage/Annotation%202020-08-08%20160941.jpg" alt="" width="585" height="246" data-is-external-image="true"></p><p>Đúng như tính chất của TCP chúng ta cần có liên kết 2 chiều trước khi server và client có thể trao đổi thông điệp với nhau.</p><p>Ban đầu, phía server tạo Socket được ràng buộc với một cổng (port number) để chờ nhận yêu cầu từ phía client.</p><p>Tiếp đến phía client yêu cầu server bằng cách tạo một Socket TCP trên máy kèm với địa chỉ IP và port number của tiến tình tương ứng trên máy server. Khi client tạo Socket, client TCP tạo liên kết với server TCP và chờ chấp nhận kết nối từ server.</p><p>TCP cung cấp dịch vụ truyền dòng tin cậy và có thứ tự giữa client và server, giữa máy chủ và máy nhận chỉ có 1 địa chỉ IP duy nhất. Thêm vào đó, mỗi thông điệp truyền đi đều có xác nhận trả về.</p><p>Sau đây là một ví dụ ứng dụng đơn giản về lập trình TCP Socket với Java.</p><p>Miêu tả ứng dụng:</p><ul><li>Client đọc dòng văn bản nhập từ bàn phím người dùng , gửi tới server qua Socket</li><li>Server đọc các dòng văn bản gửi từ Socket</li><li>Server sẽ chuyển lại dòng văn bản kèm theo “Server accepted” tới phía client qua Socket</li><li>Client đọc dòng văn bản từ socket và in ra dòng văn bản nhận được từ server</li></ul><p><img loading="lazy" src="https://s3-sgn09.fptcloud.com/codelearnstorage/Media/Default/Users/tria3ltt_40gmail_2Ecom/socketJavaImage/Annotation%202020-08-08%20132421.jpg" alt="" width="557" height="370" data-is-external-image="true"></p><p>Chúng ta có thể thấy rằng mỗi phía server và client đều có 2 luồng dữ liệu, một luồng ra Socket để gửi thông điệp và một luồng vào từ Socket để nhận thông điệp, như vậy với mỗi bên mình có hai biến input và output (inFromServer, outToServer và inFromClient, outToClient).</p><p>Trong ví dụ này mình dùng công cụ NetBeans IDE  và Socket Class, serverSocket của Java. Sau đây là file java cho phía server:</p><pre class="language-java" tabindex="0"><code>package socket;
import java.io.*;
import java.net.Socket;
import java.net.ServerSocket;
public class serverTCP {
    public static void main(String argv[]) throws Exception
    {
        String sentence_from_client;
        String sentence_to_client;
        
        //Tạo socket server, chờ tại cổng '6543'
        ServerSocket welcomeSocket = new ServerSocket(6543);
        
        while(true) {
            //chờ yêu cầu từ client
            Socket connectionSocket = welcomeSocket.accept();
            
            //Tạo input stream, nối tới Socket
            BufferedReader inFromClient =
                new BufferedReader(new
                    InputStreamReader(connectionSocket.getInputStream())); 
            
            //Tạo outputStream, nối tới socket
            DataOutputStream outToClient =
                new DataOutputStream(connectionSocket.getOutputStream());
            
            //Đọc thông tin từ socket
            sentence_from_client = inFromClient.readLine();
            
            sentence_to_client = sentence_from_client +" (Server accepted!)" + '\n';
            //ghi dữ liệu ra socket
            outToClient.writeBytes(sentence_to_client); 
            return;
        }
        
    }
}</code></pre><p>Ở đây mình tạo 2 biến <code>String</code> để nhận và gửi dữ liệu cho/từ phía client, và một biến của ServerSocket để chờ liên kết từ phía client, với số cổng là một số ngẫu nhiên lớn hơn 1024 ( trong một số hệ thống yêu cầu đặc quyền quản trị để ràng buộc số cổng &lt; 1024), ở đây mình chọn 6543.</p><p>Tiếp theo trong vòng lặp <code>While</code> mình cho giá tị true để serversocket luôn chấp nhận liên kết từ client, các bạn có thể chèn thêm điều kiện dừng cho vòng lặp. Như đã nói ở trên mình sẽ tạo 1 socket connectionSocket để nhận một đối tượng socket từ server đồng thời chấp nhận liên kết từ client qua phương thức accept().</p><p>Sau đó là 2 biến inFromClient và outToClient để nhận và gửi dữ liệu lên socket.</p><p>Biến sentence_from_client sẽ lấy dòng văn bản được truyền từ phía client thông qua biến inFromClient, biến sentence_to_client được gán bằng biến sentence_from_client + “ (Server accepted!)”.</p><p>Biến sentence_to_client sẽ được chuyển lên Socket qua phương thức writeBytes().</p><p>Còn về phía client:</p><pre class="language-java" tabindex="0"><code>package socket;
import java.io.*;
import java.net.Socket;
public class clientTCP {
    public static void main(String argv[]) throws Exception
    {
        String sentence_to_server;
        String sentence_from_server;
    
        //Tạo Inputstream(từ bàn phím)
        System.out.print("Input from client: ");
        BufferedReader inFromUser =
            new BufferedReader(new InputStreamReader(System.in));
        //Lấy chuỗi ký tự nhập từ bàn phím
        sentence_to_server = inFromUser.readLine();
//    
        //Tạo socket cho client kết nối đến server qua ID address và port number
        Socket clientSocket = new Socket("127.0.0.1", 6543);
    
        //Tạo OutputStream nối với Socket
        DataOutputStream outToServer =
            new DataOutputStream(clientSocket.getOutputStream());
    
        //Tạo inputStream nối với Socket
        BufferedReader inFromServer =
            new BufferedReader(new
            InputStreamReader(clientSocket.getInputStream()));
//     
        //Gửi chuỗi ký tự tới Server thông qua outputStream đã nối với Socket (ở trên)
        outToServer.writeBytes(sentence_to_server + '\n');
    
        //Đọc tin từ Server thông qua InputSteam đã nối với socket
        sentence_from_server = inFromServer.readLine();
    
        //print kết qua ra màn hình
        System.out.println("FROM SERVER: " + sentence_from_server);
    
        //Đóng liên kết socket
        clientSocket.close();    
    } 
}</code></pre><p>Mình cũng có 2 biến String để nhận và gửi dòng văn bản. Nhận văn bản được nhập từ bàn phím cho biến sentence_to_server qua biến inFromUser.</p><p>Tiếp theo là tạo một socket bên client hướng liên kết tới địa chỉ IP “localhost” và cổng 6543 giống với số cổng Server, ở đây vì mình đang sử dụng trên một máy tính lên địa chỉ IP để là “localhost” hoặc “127.0.0.1”, máy tính sẽ tham chiếu tới chính nó.</p><p>Tạo 2 biến outToServer và inFomServer để nhận và gửi dữ liệu.</p><p>Biến sentence_to_server sẽ được chuyển lên socket để truyền tới server qua phương thức writeBytes().</p><p>Sau khi server nhận dòng văn bản, xử lí và chuyển lên socket, biến <code>sentence_from_server</code> sẽ nhận dòng văn bản đó thông qua phương thức readLine(). Cuối cùng chúng ta in ra dòng văn bản vừa nhận từ Server và đong socket bằng phương thức close().</p><p>Để chạy được ví dụ này chúng ta cần run file java phía server trước để thiết lập server socket, sau đó run file java phía client. Đây là kết quả sau khi chạy lần lượt 2 file trên.</p><p><img loading="lazy" src="https://s3-sgn09.fptcloud.com/codelearnstorage/Media/Default/Users/tria3ltt_40gmail_2Ecom/socketJavaImage/Annotation%202020-08-08%20163442.jpg" alt="" width="530" height="201" data-is-external-image="true"></p><h3>3. Lời kết</h3><p>Qua bài này, mình và các bạn đã tìm hiểu khái niệm về socket cũng như cách lập trình socket với TCP trong java. Về cơ bản lập trình Socket trong các ngôn ngữ lập trình khác không có nhiều khác biệt, việc viết các chương trình giao tiếp như vậy trong nhiều ngôn ngữ khác nhau giúp các bạn luyện tập tốt hơn trong quá trình học tập. Trong bài viết có nhiều thuật ngữ, khái niệm liên quan đến mạng máy tính, nếu có cơ hội mình sẽ viết trong các bài blog tiếp theo. Cảm ơn các bạn đọc. Chúc các bạn thành công trên con đường học tập!</p></div><footer class="content__footer"><div class="entry-wrapper"><p class="content__updated">This article was updated on December 29, 2024</p><div class="content__actions"><div class="content__share"><button class="btn--icon content__share-button js-content__share-button"><svg width="20" height="20" aria-hidden="true"><use xlink:href="https://github.com/HuyPhuongVN/PhuongBlog.git/assets/svg/svg-map.svg#share"></use></svg> <span>Share It</span></button><div class="content__share-popup js-content__share-popup"></div></div></div></div></footer></article><div class="content__related related"><div class="wrapper"><h2 class="h4 related__title">You should also read:</h2><article class="feed__item feed__item--centered"><div class="feed__content"><header><div class="feed__meta"><a href="https://github.com/HuyPhuongVN/PhuongBlog.git/rainblog/huyphuong/" class="feed__author">Trần Huy Phương</a> <time datetime="2024-12-27T19:35" class="feed__date">December 27, 2024</time></div><h3 class="feed__title"><a href="https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-7-lap-trinh-socket-cho-giao-thuc-udp/">Chương 7: Lập trình socket cho giao thức UDP</a></h3></header><p>1. Lập tình socket với UDP Đầu tiên, UDP là viết tắt của User Datagram Protocol. UDP được giới thiệu vào năm 1980 và là một trong những giao thức mạng lâu đời nhất còn được sử dụng. UDP được sử dụng cho những đường&hellip;</p><a href="https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-7-lap-trinh-socket-cho-giao-thuc-udp/" class="readmore feed__readmore">Continue reading...</a></div></article><article class="feed__item feed__item--centered"><div class="feed__content"><header><div class="feed__meta"><a href="https://github.com/HuyPhuongVN/PhuongBlog.git/rainblog/huyphuong/" class="feed__author">Trần Huy Phương</a> <time datetime="2024-12-27T19:33" class="feed__date">December 27, 2024</time></div><h3 class="feed__title"><a href="https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-6-ky-thuat-da-tien-trinh-va-tuan-tu-hoa-ung-dung-mang/">Chương 6: Kỹ thuật đa tiến trình và tuần tự hoá... Ứng dụng mạng</a></h3></header><p>Kỹ Thuật Đa Tiến Trình và Tuần Tự Hoá: Ứng Dụng Mạng Trong thế giới lập trình hiện đại, việc xử lý các tác vụ phức tạp và tối ưu hóa hiệu suất hệ thống là điều không thể thiếu. Một trong những kỹ thuật&hellip;</p><a href="https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-6-ky-thuat-da-tien-trinh-va-tuan-tu-hoa-ung-dung-mang/" class="readmore feed__readmore">Continue reading...</a></div></article><article class="feed__item feed__item--centered"><div class="feed__content"><header><div class="feed__meta"><a href="https://github.com/HuyPhuongVN/PhuongBlog.git/rainblog/huyphuong/" class="feed__author">Trần Huy Phương</a> <time datetime="2024-12-27T19:29" class="feed__date">December 27, 2024</time></div><h3 class="feed__title"><a href="https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-4-quan-ly-dia-chi-ket-noi-mang/">Chương 4: Quản lý địa chỉ kết nối mạng</a></h3></header><p>Giới thiệu Trong lập trình Java, việc làm việc với địa chỉ mạng và URL rất quan trọng, đặc biệt khi xây dựng các ứng dụng mạng hoặc web. Java cung cấp hai lớp mạnh mẽ là InetAddress và URL trong gói java.net để hỗ&hellip;</p><a href="https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-4-quan-ly-dia-chi-ket-noi-mang/" class="readmore feed__readmore">Continue reading...</a></div></article></div></div></main><footer class="footer footer--glued"><div class="wrapper"><div class="footer__copyright"><p>Powered by Publii</p></div><button onclick="backToTopFunction()" id="backToTop" class="footer__bttop" aria-label="Back to top" title="Back to top"><svg width="20" height="20"><use xlink:href="https://github.com/HuyPhuongVN/PhuongBlog.git/assets/svg/svg-map.svg#toparrow"/></svg></button></div></footer><script defer="defer" src="https://github.com/HuyPhuongVN/PhuongBlog.git/assets/js/scripts.min.js?v=700105c316933a8202041b6415abb233"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>