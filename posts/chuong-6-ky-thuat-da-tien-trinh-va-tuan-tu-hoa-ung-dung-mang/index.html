<!DOCTYPE html><html lang="en-us"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Chương 6: Kỹ thuật đa tiến trình và tuần tự hoá... Ứng dụng mạng - Huy Phuong&#x27;s Blog</title><meta name="description" content="Kỹ Thuật Đa Tiến Trình và Tuần Tự Hoá: Ứng Dụng Mạng Trong thế giới lập trình hiện đại, việc xử lý các tác vụ phức tạp và tối ưu hóa hiệu suất hệ thống là điều không thể thiếu. Một trong những kỹ thuật&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-6-ky-thuat-da-tien-trinh-va-tuan-tu-hoa-ung-dung-mang/"><link rel="alternate" type="application/atom+xml" href="https://github.com/HuyPhuongVN/PhuongBlog.git/feed.xml"><link rel="alternate" type="application/json" href="https://github.com/HuyPhuongVN/PhuongBlog.git/feed.json"><meta property="og:title" content="Chương 6: Kỹ thuật đa tiến trình và tuần tự hoá... Ứng dụng mạng"><meta property="og:image" content="https://github.com/HuyPhuongVN/PhuongBlog.git/media/website/383700-final.jpg"><meta property="og:image:width" content="1920"><meta property="og:image:height" content="1080"><meta property="og:site_name" content="Huy Phuong's Blog"><meta property="og:description" content="Kỹ Thuật Đa Tiến Trình và Tuần Tự Hoá: Ứng Dụng Mạng Trong thế giới lập trình hiện đại, việc xử lý các tác vụ phức tạp và tối ưu hóa hiệu suất hệ thống là điều không thể thiếu. Một trong những kỹ thuật&hellip;"><meta property="og:url" content="https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-6-ky-thuat-da-tien-trinh-va-tuan-tu-hoa-ung-dung-mang/"><meta property="og:type" content="article"><link rel="stylesheet" href="https://github.com/HuyPhuongVN/PhuongBlog.git/assets/css/style.css?v=92daebec56bf325fb98046e3d45c1e86"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-6-ky-thuat-da-tien-trinh-va-tuan-tu-hoa-ung-dung-mang/"},"headline":"Chương 6: Kỹ thuật đa tiến trình và tuần tự hoá... Ứng dụng mạng","datePublished":"2024-12-27T19:33+07:00","dateModified":"2024-12-29T12:31+07:00","description":"Kỹ Thuật Đa Tiến Trình và Tuần Tự Hoá: Ứng Dụng Mạng Trong thế giới lập trình hiện đại, việc xử lý các tác vụ phức tạp và tối ưu hóa hiệu suất hệ thống là điều không thể thiếu. Một trong những kỹ thuật&hellip;","author":{"@type":"Person","name":"Trần Huy Phương","url":"https://github.com/HuyPhuongVN/PhuongBlog.git/rainblog/huyphuong/"},"publisher":{"@type":"Organization","name":"Trần Huy Phương"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body class="post-template"><header class="top js-header"><a class="logo" href="https://github.com/HuyPhuongVN/PhuongBlog.git/">Huy Phuong&#x27;s Blog</a><div class="search"><div class="search__overlay js-search-overlay"><div class="wrapper search__overlay-inner"></div></div><button class="search__btn btn--icon js-search-btn" aria-label="Search"><svg height="18" width="18" role="presentation" focusable="false"><use xlink:href="https://github.com/HuyPhuongVN/PhuongBlog.git/assets/svg/svg-map.svg#search"/></svg></button></div></header><main class="post"><article class="content"><div class="hero hero--noimage"><header class="hero__content"><div class="wrapper"><h1>Chương 6: Kỹ thuật đa tiến trình và tuần tự hoá... Ứng dụng mạng</h1><div class="feed__meta content__meta"><a href="https://github.com/HuyPhuongVN/PhuongBlog.git/rainblog/huyphuong/" class="feed__author">Trần Huy Phương</a> <time datetime="2024-12-27T19:33" class="feed__date">December 27, 2024</time></div></div></header></div><div class="entry-wrapper content__entry"><h3><strong>Kỹ Thuật Đa Tiến Trình và Tuần Tự Hoá: Ứng Dụng Mạng</strong></h3><p>Trong thế giới lập trình hiện đại, việc xử lý các tác vụ phức tạp và tối ưu hóa hiệu suất hệ thống là điều không thể thiếu. Một trong những kỹ thuật quan trọng trong việc này là <strong>đa tiến trình</strong> và <strong>tuần tự hoá đối tượng</strong>. Cùng tôi khám phá cách những kỹ thuật này có thể cải thiện hiệu suất ứng dụng mạng của bạn!</p><p>Trong lập trình, đặc biệt là khi xây dựng ứng dụng mạng, việc tối ưu hoá hiệu suất và đảm bảo tính ổn định là rất quan trọng. <strong>Đa tiến trình</strong> và <strong>tuần tự hoá đối tượng</strong> là hai kỹ thuật quan trọng giúp đạt được điều này. Hãy cùng tìm hiểu và xem các ví dụ về cách sử dụng chúng trong Java.</p><h4><strong>1. Đa Tiến Trình trong Java</strong></h4><p>Đa tiến trình cho phép bạn thực thi nhiều tác vụ đồng thời, giúp cải thiện hiệu suất và tốc độ phản hồi. Điều này đặc biệt quan trọng khi xây dựng các ứng dụng mạng cần xử lý nhiều tác vụ cùng một lúc.</p><h5><strong>Ví dụ minh hoạ: Đa Tiến Trình với Máy Chủ Đơn Giản trong Java</strong></h5><pre>import java.util.concurrent.ExecutorService;<br>import java.util.concurrent.Executors;<br><br>public class MultiThreadedServer {<br>    public static void main(String[] args) {<br>        ExecutorService executorService = Executors.newFixedThreadPool(5);  // Tạo một pool 5 tiến trình<br><br>        for (int i = 0; i &lt; 5; i++) {<br>            int requestId = i;<br>            executorService.submit(() -&gt; handleRequest(requestId));  // Gửi yêu cầu đến tiến trình xử lý<br>        }<br><br>        executorService.shutdown();  // Đóng executor service khi sử dụng xong<br>    }<br><br>    private static void handleRequest(int requestId) {<br>        System.out.println("Đang xử lý yêu cầu #" + requestId + " trong tiến trình " + Thread.currentThread().getName());<br>        try {<br>            Thread.sleep(2000);  // Giả lập thời gian xử lý yêu cầu<br>        } catch (InterruptedException e) {<br>            e.printStackTrace();<br>        }<br>        System.out.println("Yêu cầu #" + requestId + " đã hoàn thành.");<br>    }<br>}<br><br></pre><p><strong>Giải thích</strong>:</p><ul><li><strong>ExecutorService</strong> được sử dụng để quản lý pool các tiến trình.</li><li>Máy chủ sẽ xử lý đồng thời 5 yêu cầu, mỗi yêu cầu được xử lý bởi một tiến trình khác nhau.</li><li>Mỗi yêu cầu được giả lập xử lý với <code>Thread.sleep()</code>.</li></ul><h5><strong>Lợi ích của Đa Tiến Trình trong Java</strong>:</h5><ul><li><strong>Tăng hiệu suất</strong>: Xử lý đồng thời nhiều yêu cầu, giảm thiểu thời gian chờ đợi.</li><li><strong>Sử dụng tài nguyên hiệu quả</strong>: Tận dụng sức mạnh của các bộ vi xử lý đa lõi.</li><li><strong>Giảm độ trễ</strong>: Đặc biệt hữu ích trong các ứng dụng thời gian thực hoặc mạng.</li></ul><h4><strong>2. Tuần Tự Hoá Đối Tượng trong Java</strong></h4><p><strong>Tuần tự hoá đối tượng</strong> là quá trình chuyển đổi các đối tượng thành một chuỗi byte để có thể lưu trữ hoặc truyền tải qua mạng, sau đó phục hồi lại đối tượng khi cần thiết. Điều này rất quan trọng trong các ứng dụng mạng khi dữ liệu cần được truyền tải giữa các hệ thống khác nhau.</p><h5><strong>Ví dụ minh hoạ: Tuần Tự Hoá Đối Tượng trong Java</strong></h5><pre>import java.io.*;<br><br>class User implements Serializable {<br>    private String username;<br>    private String email;<br><br>    public User(String username, String email) {<br>        this.username = username;<br>        this.email = email;<br>    }<br><br>    public String getUsername() {<br>        return username;<br>    }<br><br>    public String getEmail() {<br>        return email;<br>    }<br><br>    @Override<br>    public String toString() {<br>        return "User{username='" + username + "', email='" + email + "'}";<br>    }<br>}<br><br>public class SerializationExample {<br>    public static void main(String[] args) {<br>        User user = new User("huyphuong", "huyphuong@example.com");<br><br>        // Tuần tự hoá đối tượng vào một tệp<br>        try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("user.ser"))) {<br>            out.writeObject(user);<br>            System.out.println("Đối tượng đã được tuần tự hoá: " + user);<br>        } catch (IOException e) {<br>            e.printStackTrace();<br>        }<br><br>        // Phục hồi đối tượng từ tệp<br>        try (ObjectInputStream in = new ObjectInputStream(new FileInputStream("user.ser"))) {<br>            User deserializedUser = (User) in.readObject();<br>            System.out.println("Đối tượng đã phục hồi: " + deserializedUser);<br>        } catch (IOException | ClassNotFoundException e) {<br>            e.printStackTrace();<br>        }<br>    }<br>}</pre><p><strong>Giải thích</strong>:</p><ul><li>Lớp <code>User</code> implements <code>Serializable</code> để có thể tuần tự hoá các đối tượng của lớp này.</li><li>Đối tượng <code>user</code> được tuần tự hoá vào tệp <code>user.ser</code>, sau đó phục hồi lại từ tệp này.</li><li>Kỹ thuật tuần tự hoá giúp truyền tải đối tượng qua mạng hoặc lưu trữ trạng thái của đối tượng.</li></ul><h5><strong>Lợi ích của Tuần Tự Hoá trong Java</strong>:</h5><ul><li><strong>Truyền tải dữ liệu</strong>: Tuần tự hoá đối tượng để có thể gửi qua mạng giữa các hệ thống.</li><li><strong>Lưu trữ trạng thái</strong>: Giúp lưu trữ trạng thái của đối tượng khi ứng dụng bị gián đoạn.</li><li><strong>Giao tiếp giữa các hệ thống</strong>: Có thể truyền tải dữ liệu qua các hệ thống khác nhau, kể cả những hệ thống không giống nhau về nền tảng.</li></ul><h4><strong>3. Kết Hợp Đa Tiến Trình và Tuần Tự Hoá trong Ứng Dụng Mạng</strong></h4><p>Bây giờ, chúng ta sẽ kết hợp cả <strong>đa tiến trình</strong> và <strong>tuần tự hoá</strong> để tạo ra một ứng dụng mạng, nơi nhiều tiến trình sẽ xử lý yêu cầu và tuần tự hoá dữ liệu để truyền tải.</p><h5><strong>Ví dụ Minh Hoạ: Máy Chủ Đa Tiến Trình với Tuần Tự Hoá trong Ứng Dụng Mạng</strong></h5><pre>import java.io.*;<br>import java.net.*;<br>import java.util.concurrent.ExecutorService;<br>import java.util.concurrent.Executors;<br><br>class User implements Serializable {<br>    private String username;<br>    private String email;<br><br>    public User(String username, String email) {<br>        this.username = username;<br>        this.email = email;<br>    }<br><br>    public String getUsername() {<br>        return username;<br>    }<br><br>    public String getEmail() {<br>        return email;<br>    }<br><br>    @Override<br>    public String toString() {<br>        return "User{username='" + username + "', email='" + email + "'}";<br>    }<br>}<br><br>public class NetworkServer {<br>    public static void main(String[] args) throws IOException {<br>        ServerSocket serverSocket = new ServerSocket(8080);<br>        ExecutorService executorService = Executors.newFixedThreadPool(5);  // Pool 5 tiến trình<br><br>        System.out.println("Server đang lắng nghe tại cổng 8080...");<br><br>        while (true) {<br>            Socket socket = serverSocket.accept();<br>            System.out.println("Khách hàng đã kết nối: " + socket.getInetAddress());<br><br>            executorService.submit(() -&gt; {<br>                try {<br>                    // Xử lý yêu cầu trong tiến trình riêng<br>                    ObjectInputStream input = new ObjectInputStream(socket.getInputStream());<br>                    User user = (User) input.readObject();<br>                    System.out.println("Nhận dữ liệu người dùng: " + user);<br><br>                    // Gửi lại dữ liệu tuần tự hoá cho khách hàng<br>                    ObjectOutputStream output = new ObjectOutputStream(socket.getOutputStream());<br>                    output.writeObject(new User("server_response", "response@example.com"));<br>                    System.out.println("Gửi phản hồi cho khách hàng.");<br><br>                    socket.close();<br>                } catch (IOException | ClassNotFoundException e) {<br>                    e.printStackTrace();<br>                }<br>            });<br>        }<br>    }<br>}</pre><p><strong>Giải thích</strong>:</p><ul><li>Máy chủ lắng nghe kết nối từ khách hàng trên cổng 8080.</li><li>Khi một khách hàng kết nối, máy chủ sẽ tạo một tiến trình mới để xử lý yêu cầu của khách hàng.</li><li>Dữ liệu từ khách hàng được tuần tự hoá và gửi lại thông qua mạng.</li></ul><hr><h3><strong>Kết Luận</strong></h3><p>Kết hợp <strong>đa tiến trình</strong> và <strong>tuần tự hoá đối tượng</strong> trong Java giúp bạn xây dựng các ứng dụng mạng hiệu quả và dễ mở rộng. Đa tiến trình giúp tăng cường khả năng xử lý đồng thời, trong khi tuần tự hoá giúp bạn truyền tải và lưu trữ dữ liệu một cách hiệu quả.</p><p>Cả hai kỹ thuật này đều rất quan trọng khi xây dựng các ứng dụng mạng hoặc hệ thống phân tán, và sẽ giúp bạn cải thiện hiệu suất và độ ổn định của ứng dụng.</p></div><footer class="content__footer"><div class="entry-wrapper"><p class="content__updated">This article was updated on December 29, 2024</p><div class="content__actions"><div class="content__share"><button class="btn--icon content__share-button js-content__share-button"><svg width="20" height="20" aria-hidden="true"><use xlink:href="https://github.com/HuyPhuongVN/PhuongBlog.git/assets/svg/svg-map.svg#share"></use></svg> <span>Share It</span></button><div class="content__share-popup js-content__share-popup"></div></div></div></div></footer></article><div class="content__related related"><div class="wrapper"><h2 class="h4 related__title">You should also read:</h2><article class="feed__item feed__item--centered"><div class="feed__content"><header><div class="feed__meta"><a href="https://github.com/HuyPhuongVN/PhuongBlog.git/rainblog/huyphuong/" class="feed__author">Trần Huy Phương</a> <time datetime="2024-12-27T19:35" class="feed__date">December 27, 2024</time></div><h3 class="feed__title"><a href="https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-7-lap-trinh-socket-cho-giao-thuc-udp/">Chương 7: Lập trình socket cho giao thức UDP</a></h3></header><p>1. Lập tình socket với UDP Đầu tiên, UDP là viết tắt của User Datagram Protocol. UDP được giới thiệu vào năm 1980 và là một trong những giao thức mạng lâu đời nhất còn được sử dụng. UDP được sử dụng cho những đường&hellip;</p><a href="https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-7-lap-trinh-socket-cho-giao-thuc-udp/" class="readmore feed__readmore">Continue reading...</a></div></article><article class="feed__item feed__item--centered"><div class="feed__content"><header><div class="feed__meta"><a href="https://github.com/HuyPhuongVN/PhuongBlog.git/rainblog/huyphuong/" class="feed__author">Trần Huy Phương</a> <time datetime="2024-12-27T19:32" class="feed__date">December 27, 2024</time></div><h3 class="feed__title"><a href="https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-5-lap-trinh-socket-cho-giao-thuc-tcp/">Chương 5: Lập trình socket cho giao thức TCP</a></h3></header><p>Socket được biết đến là cánh cửa giao tiếp giữa hai tiến trình ứng dụng. Socket hỗ trợ nhiều ngôn ngữ (C, java, perl, python,…) cũng như nhiều platform (*nix, Windows,…). Socket được viết bằng các ngôn ngữ khác nhau và chạy trên bất kỳ&hellip;</p><a href="https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-5-lap-trinh-socket-cho-giao-thuc-tcp/" class="readmore feed__readmore">Continue reading...</a></div></article><article class="feed__item feed__item--centered"><div class="feed__content"><header><div class="feed__meta"><a href="https://github.com/HuyPhuongVN/PhuongBlog.git/rainblog/huyphuong/" class="feed__author">Trần Huy Phương</a> <time datetime="2024-12-27T19:29" class="feed__date">December 27, 2024</time></div><h3 class="feed__title"><a href="https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-4-quan-ly-dia-chi-ket-noi-mang/">Chương 4: Quản lý địa chỉ kết nối mạng</a></h3></header><p>Giới thiệu Trong lập trình Java, việc làm việc với địa chỉ mạng và URL rất quan trọng, đặc biệt khi xây dựng các ứng dụng mạng hoặc web. Java cung cấp hai lớp mạnh mẽ là InetAddress và URL trong gói java.net để hỗ&hellip;</p><a href="https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-4-quan-ly-dia-chi-ket-noi-mang/" class="readmore feed__readmore">Continue reading...</a></div></article></div></div></main><footer class="footer footer--glued"><div class="wrapper"><div class="footer__copyright"><p>Powered by Publii</p></div><button onclick="backToTopFunction()" id="backToTop" class="footer__bttop" aria-label="Back to top" title="Back to top"><svg width="20" height="20"><use xlink:href="https://github.com/HuyPhuongVN/PhuongBlog.git/assets/svg/svg-map.svg#toparrow"/></svg></button></div></footer><script defer="defer" src="https://github.com/HuyPhuongVN/PhuongBlog.git/assets/js/scripts.min.js?v=700105c316933a8202041b6415abb233"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>